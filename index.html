<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>RX Boss — Florida Prescribed Burn GO / NO-GO</title>
  <style>
    :root{
      --bg0:#120607;
      --bg1:#22080a;
      --bg2:#2c0b0e;
      --card:#0e1116cc;
      --card2:#0e1116aa;
      --line:#ffffff1a;
      --text:#e9eef7;
      --muted:#a9b4c6;
      --hot:#ff4d4d;
      --warm:#ffb020;
      --go:#3ddc97;
      --accent:#ff3b3b;
      --accent2:#ff7a18;
      --shadow: 0 18px 60px #00000066;
      --radius: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
    }

    html,body{height:100%;}
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 700px at 20% 0%, #ff3b3b22, transparent 60%),
        radial-gradient(1000px 800px at 80% 10%, #ff7a1822, transparent 55%),
        radial-gradient(900px 700px at 50% 100%, #ff2d5520, transparent 55%),
        linear-gradient(180deg, var(--bg1), var(--bg0) 45%, #0b0d12 100%);
      overflow-x:hidden;
    }

    .wrap{max-width:1200px;margin:0 auto;padding:26px 18px 70px;}
    .topbar{display:flex;gap:14px;align-items:flex-start;justify-content:space-between;flex-wrap:wrap;}
    h1{margin:0;font-size:40px;letter-spacing:-0.02em;}
    .subtitle{margin-top:6px;color:var(--muted);max-width:850px;line-height:1.35;}
    .pillrow{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px;}
    .pill{
      font-size:12px;
      color:var(--muted);
      border:1px solid var(--line);
      background:#0b0d1280;
      padding:8px 10px;
      border-radius:999px;
      backdrop-filter: blur(8px);
    }
    .pill strong{color:var(--text);font-weight:700;}
    .pill .dot{display:inline-block;width:8px;height:8px;border-radius:99px;margin-right:8px;vertical-align:-1px;}
    .dot.live{background:var(--go);}
    .dot.cached{background:var(--warm);}
    .dot.offline{background:var(--hot);}

    .panel{
      margin-top:18px;
      background:linear-gradient(180deg, #0c0f16cc, #090b10cc);
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      overflow:hidden;
    }

    .panelHead{
      display:flex;align-items:center;justify-content:space-between;
      padding:16px 16px 0 16px;gap:12px;flex-wrap:wrap;
    }

    .drop{
      margin:14px 16px 16px 16px;
      border-radius:16px;
      border:2px dashed #ffffff2a;
      background: radial-gradient(800px 200px at 50% 0%, #ff3b3b10, transparent 60%),
                  linear-gradient(180deg, #0d1017aa, #0a0d1280);
      padding:18px 18px;
      min-height:88px;
      display:flex;align-items:center;justify-content:center;flex-direction:column;
      text-align:center;
      cursor:pointer;
      user-select:none;
    }
    .drop:hover{border-color:#ffffff45;}
    .drop h2{margin:0;font-size:16px;font-weight:800;}
    .drop p{margin:8px 0 0 0;color:var(--muted);font-size:12px;max-width:820px;line-height:1.35;}
    .drop code{font-family:var(--mono);font-size:12px;background:#00000033;border:1px solid #ffffff1f;border-radius:10px;padding:2px 6px;}

    .controls{
      display:flex;gap:10px;flex-wrap:wrap;align-items:center;
      padding:0 16px 16px 16px;
    }
    button,.btn{
      border:1px solid var(--line);
      background:#0b0d12cc;
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      font-weight:700;
      font-size:13px;
      transition: transform .05s ease, border-color .2s ease, background .2s ease;
    }
    button:hover{border-color:#ffffff3a;background:#0b0d12ee;}
    button:active{transform:translateY(1px);}
    button.primary{border-color:#ff3b3b55;background:linear-gradient(180deg,#ff3b3b22,#0b0d12cc);}
    button.primary:hover{border-color:#ff3b3b88;}
    button.danger{border-color:#ff4d4d55;}
    button.danger:hover{border-color:#ff4d4d88;}
    button:disabled{opacity:.55;cursor:not-allowed;}
    .spacer{flex:1;}

    details{
      border-top:1px solid var(--line);
      padding:0;
    }
    summary{
      list-style:none;
      cursor:pointer;
      padding:14px 16px;
      display:flex;align-items:center;justify-content:space-between;
      gap:12px;
      user-select:none;
      background:linear-gradient(180deg, #0a0d1280, transparent);
    }
    summary::-webkit-details-marker{display:none;}
    .summaryTitle{font-weight:900;}
    .summaryHint{color:var(--muted);font-size:12px;}
    .grid{
      display:grid;
      grid-template-columns: repeat(12, 1fr);
      gap:12px;
      padding:16px;
    }
    .field{
      grid-column: span 3;
      background:linear-gradient(180deg, #0e1116aa, #0b0d12aa);
      border:1px solid var(--line);
      border-radius:14px;
      padding:12px;
    }
    .field.wide{grid-column: span 6;}
    .field.full{grid-column: span 12;}
    .label{font-size:12px;color:var(--muted);margin-bottom:8px;}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap;}
    input[type="number"], input[type="text"]{
      width:100%;
      box-sizing:border-box;
      padding:9px 10px;
      border-radius:12px;
      border:1px solid #ffffff22;
      background:#00000026;
      color:var(--text);
      font-family:var(--mono);
      font-size:13px;
      outline:none;
    }
    input[type="number"]:focus,input[type="text"]:focus{border-color:#ff3b3b66;}
    input[type="checkbox"]{leading-trim:both;}
    .check{display:flex;gap:10px;align-items:center;color:var(--text);font-size:13px;}
    .small{font-size:12px;color:var(--muted);line-height:1.25;margin-top:8px;}

    .status{
      padding:12px 16px 0 16px;
      color:var(--muted);
      font-size:13px;
      display:flex;gap:12px;flex-wrap:wrap;align-items:center;
    }
    .status strong{color:var(--text);}
    .divider{height:1px;background:var(--line);margin:12px 0;}

    .cardsWrap{
      margin-top:18px;
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap:14px;
    }
    @media (max-width: 1000px){ .cardsWrap{grid-template-columns: repeat(2, 1fr);} .field{grid-column: span 6;} }
    @media (max-width: 680px){ .cardsWrap{grid-template-columns: 1fr;} .field{grid-column: span 12;} }

    .card{
      background:linear-gradient(180deg, #0e1116cc, #0b0d12cc);
      border:1px solid var(--line);
      border-radius:var(--radius);
      box-shadow: 0 14px 50px #00000055;
      padding:14px;
      position:relative;
      overflow:hidden;
    }
    .card::before{
      content:"";
      position:absolute;inset:-2px;
      background: radial-gradient(500px 140px at 40% 0%, #ff3b3b20, transparent 65%),
                  radial-gradient(450px 220px at 90% 0%, #ff7a1820, transparent 70%);
      opacity:.7;
      pointer-events:none;
    }
    .card > *{position:relative;}
    .cardHead{display:flex;align-items:flex-start;justify-content:space-between;gap:10px;}
    .title{font-weight:900;font-size:16px;}
    .sub{color:var(--muted);font-size:12px;margin-top:4px;}
    .badge{
      font-size:12px;
      padding:6px 10px;border-radius:999px;
      border:1px solid #ffffff22;background:#00000024;
      font-weight:900;
      letter-spacing:.02em;
      white-space:nowrap;
    }
    .b-go{border-color:#3ddc9755;color:#aaffdf;}
    .b-caution{border-color:#ffb02066;color:#ffe4b1;}
    .b-nogo{border-color:#ff4d4d66;color:#ffc3c3;}

    .kv{display:grid;grid-template-columns: 1fr auto;gap:6px 10px;margin-top:10px;font-family:var(--mono);font-size:12.5px;}
    .k{color:#dbe4f6;}
    .v{color:#ffffff;}
    .kv .muted{color:var(--muted);font-family:var(--sans);font-size:12px;grid-column: span 2;line-height:1.25;margin-top:4px;}

    .bar{
      margin-top:12px;
      height:8px;border-radius:999px;background:#ffffff14;border:1px solid #ffffff12;
      overflow:hidden;
    }
    .fill{height:100%;width:0%;background:linear-gradient(90deg, #ff3b3b, #ffb020, #3ddc97);}
    .scoreRow{display:flex;align-items:center;justify-content:space-between;margin-top:10px;color:var(--muted);font-size:12px;}
    .foot{margin-top:10px;color:var(--muted);font-size:12px;line-height:1.35;}
    .foot code{font-family:var(--mono);font-size:12px;background:#00000033;border:1px solid #ffffff1a;border-radius:8px;padding:2px 6px;}

    .toast{
      position:fixed;right:16px;bottom:16px;
      background:#0b0d12ee;border:1px solid var(--line);
      border-radius:14px;padding:12px 12px;box-shadow:var(--shadow);
      max-width:520px;color:var(--text);font-size:13px;display:none;
    }
    .toast strong{color:var(--text);}
    .toast .muted{color:var(--muted);}

    .sr{position:absolute;left:-10000px;top:auto;width:1px;height:1px;overflow:hidden;}
  </style>
</head>
<body>
<div class="wrap">
  <div class="topbar">
    <div>
      <h1>RX Boss</h1>
      <div class="subtitle">
        Florida prescribed burn <strong>GO / CAUTION / NO-GO</strong> triage tool. Upload a GeoJSON of burn units (polygons).
        The app selects up to <strong>10 best tracts</strong> by burn-quality score, using <strong>DAYTIME</strong> RH + mixing height in your burn window.
        Missing/unknown data is conservative: <strong>NO-GO</strong> (and skipped for “top tracts” ranking).
      </div>
      <div class="pillrow" id="pillrow">
        <div class="pill"><span class="dot live"></span><strong>LIVE</strong> api.weather.gov</div>
        <div class="pill"><span class="dot cached"></span><strong>CACHED</strong> localStorage (TTL)</div>
        <div class="pill"><span class="dot offline"></span><strong>OFFLINE</strong> network fail</div>
        <div class="pill"><strong>Burn window:</strong> <span id="pillWindow">09:00–18:00</span> (local)</div>
        <div class="pill"><strong>Limit:</strong> <span id="pillLimit">10 tracts</span></div>
      </div>
    </div>
  </div>

  <div class="panel">
    <div class="panelHead">
      <div class="pill"><strong>Status:</strong> <span id="statusText">Drop a GeoJSON to begin.</span></div>
      <div class="pill"><strong>Mode:</strong> <span id="modeText">Ready</span></div>
    </div>

    <label class="drop" id="dropZone" tabindex="0" aria-label="Drop GeoJSON burn units here, or click to select">
      <h2>Drop GeoJSON burn units here (or click to select)</h2>
      <p>
        Accepts <code>.geojson</code> / <code>.json</code> FeatureCollections with Polygon/MultiPolygon (WGS84 lon/lat recommended).
        If coords aren’t lon/lat, cards will flag <strong>BAD CRS</strong> and be skipped.
      </p>
      <input class="sr" id="fileInput" type="file" accept=".json,.geojson,application/geo+json,application/json" />
    </label>

    <div class="controls">
      <button class="primary" id="btnRunDemo">Load demo data</button>
      <button id="btnClear" class="danger">Clear</button>
      <button id="btnReRank">Re-rank with current settings</button>
      <div class="spacer"></div>
      <button id="btnExport" title="Export the current ranked set (JSON)">Export ranked JSON</button>
    </div>

    <details id="settingsDetails">
      <summary>
        <div>
          <div class="summaryTitle">Manual parameters (tweak without touching code)</div>
          <div class="summaryHint">Burn window, thresholds, scoring weights, caching TTL, display limit</div>
        </div>
        <div class="summaryHint">Click to open</div>
      </summary>

      <div class="grid">
        <div class="field">
          <div class="label">Burn window start (local)</div>
          <input id="burnStart" type="text" value="09:00" />
          <div class="small">Format HH:MM (24h). Default: 09:00</div>
        </div>
        <div class="field">
          <div class="label">Burn window end (local)</div>
          <input id="burnEnd" type="text" value="18:00" />
          <div class="small">Format HH:MM (24h). Default: 18:00</div>
        </div>
        <div class="field">
          <div class="label">Top tracts to show</div>
          <input id="topLimit" type="number" min="1" max="50" step="1" value="10" />
          <div class="small">One “best unit” per tract, ranked by score.</div>
        </div>
        <div class="field">
          <div class="label">Cache TTL (hours)</div>
          <input id="cacheTtlH" type="number" min="0" max="48" step="0.5" value="6" />
          <div class="small">0 disables caching.</div>
        </div>

        <div class="field">
          <div class="label">RH GO min / max (%) — daytime</div>
          <div class="row">
            <input id="rhGoMin" type="number" min="0" max="100" step="1" value="30" />
            <input id="rhGoMax" type="number" min="0" max="100" step="1" value="55" />
          </div>
          <div class="small">Daytime RH range must be within these bounds for GO.</div>
        </div>
        <div class="field">
          <div class="label">Wind max (mph)</div>
          <input id="windMax" type="number" min="0" max="60" step="0.5" value="15" />
          <div class="small">Uses max wind speed in burn window (default).</div>
        </div>
        <div class="field">
          <div class="label">Gust max (mph)</div>
          <input id="gustMax" type="number" min="0" max="80" step="0.5" value="20" />
          <div class="small">Uses max gust in burn window (default).</div>
        </div>
        <div class="field">
          <div class="label">DAYTIME min mixing height (ft)</div>
          <input id="mixMinFt" type="number" min="0" max="20000" step="10" value="1700" />
          <div class="small">This is the *min* within burn window — not 24h.</div>
        </div>

        <div class="field">
          <div class="label">QPF next 24h total max (in)</div>
          <input id="qpfSumMaxIn" type="number" min="0" max="10" step="0.01" value="0.10" />
          <div class="small">Conservative: rainfall forecast triggers CAUTION/NO-GO.</div>
        </div>

        <div class="field wide">
          <div class="label">Which variables use the burn window filter?</div>
          <div class="row">
            <label class="check"><input id="windowForWind" type="checkbox" checked /> Wind/Gust</label>
            <label class="check"><input id="windowForQpf" type="checkbox" /> QPF (default: next 24h)</label>
            <label class="check"><input id="windowForLastRain" type="checkbox" checked /> Last-rain recency label uses local time</label>
          </div>
          <div class="small">RH + Mixing ALWAYS use the burn window (this is the whole point for Florida).</div>
        </div>

        <div class="field wide">
          <div class="label">Scoring weights (0–5)</div>
          <div class="row">
            <div style="flex:1">
              <div class="label">RH weight</div>
              <input id="wRh" type="number" min="0" max="5" step="0.1" value="2.2" />
            </div>
            <div style="flex:1">
              <div class="label">Wind/Gust weight</div>
              <input id="wWind" type="number" min="0" max="5" step="0.1" value="1.8" />
            </div>
            <div style="flex:1">
              <div class="label">Mixing weight</div>
              <input id="wMix" type="number" min="0" max="5" step="0.1" value="2.2" />
            </div>
            <div style="flex:1">
              <div class="label">Rain/QPF weight</div>
              <input id="wRain" type="number" min="0" max="5" step="0.1" value="1.4" />
            </div>
          </div>
          <div class="small">Higher = more influence on the “Burn Quality Score”. Decision (GO/CAUTION/NO-GO) still uses hard thresholds.</div>
        </div>

        <div class="field full">
          <div class="label">Advanced</div>
          <div class="row">
            <label class="check"><input id="preferTractCorrectness" type="checkbox" checked /> If tract name missing → skip feature</label>
            <label class="check"><input id="skipUnknownData" type="checkbox" checked /> If required grid data missing → skip tract in ranking</label>
help text         </div>
          <div class="small">
            “If none exist → skip to next tract” is implemented as: if a tract has no units with complete data, it won’t appear in top results.
            You can still scroll the raw list by exporting JSON if you want later.
          </div>
        </div>
      </div>
    </details>
  </div>

  <div class="status" id="runStatus">
    <span><strong>Decision logic:</strong> conservative; missing data ⇒ <strong>NO-GO</strong> and excluded from top ranking.</span>
    <span><strong>Daytime:</strong> burn window only (Florida time).</span>
    <span><strong>Source:</strong> <code>api.weather.gov</code> (grid + nearest station observations).</span>
  </div>

  <div class="cardsWrap" id="cards"></div>

  <div class="toast" id="toast"></div>
</div>

<script>
/* =========================================================
   RX Boss — Single-file app (no build step)
   - Upload GeoJSON of polygons / multipolygons
   - Compute centroids
   - Pull NWS grid: api.weather.gov/points/{lat},{lon} -> forecastGridData
   - Pull nearest station observations for “last rain” recency
   - Use DAYTIME metrics (burn window) for RH and Mixing Height
   - Rank: one best unit per tract, show top N tracts
   - Conservative: missing data => NO-GO (skipped by default)
========================================================= */

(() => {
  // ---------- DOM ----------
  const el = (id) => document.getElementById(id);
  const dropZone = el("dropZone");
  const fileInput = el("fileInput");
  const cardsEl = el("cards");
  const statusText = el("statusText");
  const modeText = el("modeText");
  const toastEl = el("toast");

  // Inputs
  const burnStartEl = el("burnStart");
  const burnEndEl = el("burnEnd");
  const topLimitEl = el("topLimit");
  const cacheTtlHEl = el("cacheTtlH");

  const rhGoMinEl = el("rhGoMin");
  const rhGoMaxEl = el("rhGoMax");
  const windMaxEl = el("windMax");
  const gustMaxEl = el("gustMax");
  const mixMinFtEl = el("mixMinFt");
  const qpfSumMaxInEl = el("qpfSumMaxIn");

  const windowForWindEl = el("windowForWind");
  const windowForQpfEl = el("windowForQpf");
  const windowForLastRainEl = el("windowForLastRain");

  const wRhEl = el("wRh");
  const wWindEl = el("wWind");
  const wMixEl = el("wMix");
  const wRainEl = el("wRain");

  const preferTractCorrectnessEl = el("preferTractCorrectness");
  const skipUnknownDataEl = el("skipUnknownData");

  // Pills
  const pillWindow = el("pillWindow");
  const pillLimit = el("pillLimit");

  // Buttons
  const btnRunDemo = el("btnRunDemo");
  const btnClear = el("btnClear");
  const btnReRank = el("btnReRank");
  const btnExport = el("btnExport");

  // ---------- State ----------
  let lastGeojson = null;
  let lastResults = null; // full evaluated units
  let lastRanked = null;  // ranked best per tract
  let aborter = null;

  // ---------- Constants ----------
  const UA = "RXBoss/1.0 (single-file; contact: local)";
  const REQUIRED_GRID_FIELDS = ["relativeHumidity", "windSpeed", "windGust", "mixingHeight", "quantitativePrecipitation"];

  // ---------- Helpers (UI) ----------
  function toast(msg, ms=2800){
    toastEl.style.display = "block";
    toastEl.innerHTML = msg;
    clearTimeout(toastEl._t);
    toastEl._t = setTimeout(()=>{ toastEl.style.display="none"; }, ms);
  }

  function setStatus(msg){ statusText.textContent = msg; }
  function setMode(msg){ modeText.textContent = msg; }
  function clearCards(){ cardsEl.innerHTML = ""; }

  function fmt(n, d=0){
    if (n === null || n === undefined || Number.isNaN(n)) return "—";
    return Number(n).toFixed(d);
  }

  function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }

  function parseHHMM(s){
    const m = String(s||"").trim().match(/^(\d{1,2}):(\d{2})$/);
    if(!m) return null;
    const hh = Number(m[1]), mm = Number(m[2]);
    if(hh<0||hh>23||mm<0||mm>59) return null;
    return hh*60 + mm;
  }

  function minutesToHHMM(mins){
    const hh = Math.floor(mins/60);
    const mm = mins%60;
    return String(hh).padStart(2,"0")+":"+String(mm).padStart(2,"0");
  }

  function updatePills(){
    const bs = burnStartEl.value, be = burnEndEl.value;
    pillWindow.textContent = `${bs}–${be}`;
    pillLimit.textContent = `${topLimitEl.value} tracts`;
  }

  // ---------- Persistence ----------
  const SETTINGS_KEY = "rxboss_settings_v1";
  function readSettings(){
    try{
      const raw = localStorage.getItem(SETTINGS_KEY);
      return raw ? JSON.parse(raw) : null;
    }catch{ return null; }
  }
  function writeSettings(){
    const s = getSettings();
    localStorage.setItem(SETTINGS_KEY, JSON.stringify(s));
  }
  function applySettings(s){
    if(!s) return;
    burnStartEl.value = s.burnStart ?? "09:00";
    burnEndEl.value = s.burnEnd ?? "18:00";
    topLimitEl.value = s.topLimit ?? 10;
    cacheTtlHEl.value = s.cacheTtlH ?? 6;

    rhGoMinEl.value = s.rhGoMin ?? 30;
    rhGoMaxEl.value = s.rhGoMax ?? 55;
    windMaxEl.value = s.windMax ?? 15;
    gustMaxEl.value = s.gustMax ?? 20;
    mixMinFtEl.value = s.mixMinFt ?? 1700;
    qpfSumMaxInEl.value = s.qpfSumMaxIn ?? 0.10;

    windowForWindEl.checked = s.windowForWind ?? true;
    windowForQpfEl.checked = s.windowForQpf ?? false;
    windowForLastRainEl.checked = s.windowForLastRain ?? true;

    wRhEl.value = s.wRh ?? 2.2;
    wWindEl.value = s.wWind ?? 1.8;
    wMixEl.value = s.wMix ?? 2.2;
    wRainEl.value = s.wRain ?? 1.4;

    preferTractCorrectnessEl.checked = s.preferTractCorrectness ?? true;
    skipUnknownDataEl.checked = s.skipUnknownData ?? true;

    updatePills();
  }
  function getSettings(){
    // validate HH:MM
    const bs = parseHHMM(burnStartEl.value) ?? parseHHMM("09:00");
    const be = parseHHMM(burnEndEl.value) ?? parseHHMM("18:00");
    const burnStart = minutesToHHMM(bs);
    const burnEnd = minutesToHHMM(be);

    return {
      burnStart, burnEnd,
      topLimit: Number(topLimitEl.value||10),
      cacheTtlH: Number(cacheTtlHEl.value||6),

      rhGoMin: Number(rhGoMinEl.value||30),
      rhGoMax: Number(rhGoMaxEl.value||55),
      windMax: Number(windMaxEl.value||15),
      gustMax: Number(gustMaxEl.value||20),
      mixMinFt: Number(mixMinFtEl.value||1700),
      qpfSumMaxIn: Number(qpfSumMaxInEl.value||0.10),

      windowForWind: !!windowForWindEl.checked,
      windowForQpf: !!windowForQpfEl.checked,
      windowForLastRain: !!windowForLastRainEl.checked,

      wRh: Number(wRhEl.value||2.2),
      wWind: Number(wWindEl.value||1.8),
      wMix: Number(wMixEl.value||2.2),
      wRain: Number(wRainEl.value||1.4),

      preferTractCorrectness: !!preferTractCorrectnessEl.checked,
      skipUnknownData: !!skipUnknownDataEl.checked
    };
  }

  // ---------- Caching ----------
  function nowMs(){ return Date.now(); }
  function cacheGet(key, ttlH){
    if(ttlH <= 0) return null;
    try{
      const raw = localStorage.getItem(key);
      if(!raw) return null;
      const obj = JSON.parse(raw);
      if(!obj || !obj.t || obj.v === undefined) return null;
      const ageMs = nowMs() - obj.t;
      if(ageMs > ttlH*3600*1000) return null;
      return obj.v;
    }catch{ return null; }
  }
  function cacheSet(key, val, ttlH){
    if(ttlH <= 0) return;
    try{
      localStorage.setItem(key, JSON.stringify({t: nowMs(), v: val}));
    }catch{}
  }

  // ---------- Network ----------
  async function fetchJson(url, settings, tag){
    // tag used for caching keys
    const ttlH = settings.cacheTtlH;
    const key = `rxboss_cache::${tag}::${url}`;
    const cached = cacheGet(key, ttlH);
    if(cached){
      return { ok:true, data: cached, source:"CACHED" };
    }
    try{
      const res = await fetch(url, {
        headers: {
          "Accept": "application/geo+json, application/json",
          "User-Agent": UA
        },
        signal: aborter?.signal
      });
      if(!res.ok) throw new Error(`HTTP ${res.status}`);
      const data = await res.json();
      cacheSet(key, data, ttlH);
      return { ok:true, data, source:"LIVE" };
    }catch(e){
      return { ok:false, error: String(e), source:"OFFLINE" };
    }
  }

  // ---------- Geo helpers ----------
  function isLonLatPlausible(lon, lat){
    return (Math.abs(lon) <= 180 && Math.abs(lat) <= 90);
  }

  function centroidOfPolygon(coords){
    // coords: [ [ [lon,lat], ... ] , holes...]
    // We’ll compute centroid of outer ring via simple area-weighted formula.
    // If ring is invalid or area ~0, fallback to average of vertices.
    const ring = coords?.[0];
    if(!Array.isArray(ring) || ring.length < 3) return null;

    let A=0, Cx=0, Cy=0;
    for(let i=0;i<ring.length-1;i++){
      const [x0,y0] = ring[i];
      const [x1,y1] = ring[i+1];
      const cross = x0*y1 - x1*y0;
      A += cross;
      Cx += (x0 + x1) * cross;
      Cy += (y0 + y1) * cross;
    }
    A *= 0.5;
    if(Math.abs(A) < 1e-10){
      // average
      let sx=0, sy=0, n=0;
      for(const p of ring){
        if(Array.isArray(p) && p.length>=2){
          sx += p[0]; sy += p[1]; n++;
        }
      }
      if(n===0) return null;
      return { lon: sx/n, lat: sy/n };
    }
    Cx = Cx/(6*A);
    Cy = Cy/(6*A);
    return { lon: Cx, lat: Cy };
  }

  function centroidOfGeometry(geom){
    if(!geom) return null;
    const t = geom.type;
    const c = geom.coordinates;
    if(t === "Polygon"){
      return centroidOfPolygon(c);
    }
    if(t === "MultiPolygon"){
      // area-weighted average of polygon centroids
      let sumLon=0, sumLat=0, sumW=0;
      for(const poly of c){
        const cent = centroidOfPolygon(poly);
        if(!cent) continue;
        // weight by polygon outer ring point count (cheap proxy)
        const w = (poly?.[0]?.length || 1);
        sumLon += cent.lon*w; sumLat += cent.lat*w; sumW += w;
      }
      if(sumW === 0) return null;
      return { lon: sumLon/sumW, lat: sumLat/sumW };
    }
    // Not supported
    return null;
  }

  function pickProp(props, keys){
    for(const k of keys){
      if(props && props[k] !== undefined && props[k] !== null && String(props[k]).trim() !== ""){
        return String(props[k]).trim();
      }
    }
    return null;
  }

  function getUnitId(props, fallbackIndex){
    return pickProp(props, ["Ident","IDENT","ident","Unit","UNIT","unit","Name","NAME","name","UnitID","unit_id","ID","id"]) || `Unit-${fallbackIndex+1}`;
  }

  function getTract(props){
    return pickProp(props, ["Tract","TRACT","tract","TractName","TRACTNAME","Tract_Name","tract_name","MgmtUnit","ManagementUnit","Area","AREA"]);
  }

  // ---------- Time series expansion (NWS grid) ----------
  // NWS grid values are like:
  //   { validTime: "2026-01-12T12:00:00+00:00/PT1H", value: 53 }
  // We expand each interval into hourly points (start time each hour).
  function parseValidTimeInterval(validTime){
    // returns {startMs, hours}
    // "YYYY-MM-DDTHH:mm:ssZ/PTnH" or PTnHnM
    const parts = String(validTime||"").split("/");
    if(parts.length !== 2) return null;
    const start = Date.parse(parts[0]);
    const dur = parts[1];
    if(Number.isNaN(start)) return null;
    const m = dur.match(/^PT(?:(\d+)H)?(?:(\d+)M)?$/);
    if(!m) return null;
    const h = Number(m[1]||0);
    const min = Number(m[2]||0);
    const hours = h + (min/60);
    return { startMs: start, hours: hours || 0 };
  }

  function expandToHourly(values){
    const out = [];
    for(const it of (values||[])){
      if(!it || it.value === null || it.value === undefined) continue;
      const iv = parseValidTimeInterval(it.validTime);
      if(!iv) continue;
      const steps = Math.max(1, Math.round(iv.hours)); // typical is 1H
      for(let k=0;k<steps;k++){
        const t = iv.startMs + k*3600*1000;
        out.push({ t, v: it.value });
      }
    }
    // de-dup by time (keep last)
    out.sort((a,b)=>a.t-b.t);
    const dedup = [];
    for(const p of out){
      const last = dedup[dedup.length-1];
      if(last && last.t === p.t) last.v = p.v;
      else dedup.push(p);
    }
    return dedup;
  }

  // Convert / parse units
  function parseWindMph(val){
    // NWS windSpeed value might be like "10 mph" OR number (knots?) but grid uses "unitCode": "wmoUnit:km_h-1" sometimes.
    // Grid value for windSpeed is usually a number (m/s?) depending on unitCode.
    // We’ll handle:
    //  - number with unitCode: mph/kmh/knots/ms (convert)
    //  - string "10 mph"
    if(val === null || val === undefined) return null;
    if(typeof val === "string"){
      const m = val.match(/(-?\d+(?:\.\d+)?)\s*(mph|km\/h|kph|kt|knots|m\/s)?/i);
      if(!m) return null;
      const num = Number(m[1]);
      const u = (m[2]||"mph").toLowerCase();
      return convertSpeedToMph(num, u);
    }
    if(typeof val === "number"){
      return val; // if already converted upstream using unitCode
    }
    return null;
  }

  function convertSpeedToMph(x, unit){
    if(x === null || x === undefined || Number.isNaN(x)) return null;
    const u = (unit||"").toLowerCase();
    if(u.includes("mph")) return x;
    if(u.includes("km") || u.includes("kph") || u.includes("km_h")) return x * 0.621371;
    if(u.includes("kt") || u.includes("knot")) return x * 1.15078;
    if(u.includes("m/s") || u.includes("ms")) return x * 2.23694;
    // unknown -> assume mph
    return x;
  }

  function convertLengthToFeet(x, unit){
    if(x === null || x === undefined || Number.isNaN(x)) return null;
    const u = (unit||"").toLowerCase();
    if(u.includes("ft")) return x;
    if(u.includes("m")) return x * 3.28084;
    return x; // assume feet if unknown
  }

  function convertPrecipToInches(x, unit){
    if(x === null || x === undefined || Number.isNaN(x)) return null;
    const u = (unit||"").toLowerCase();
    if(u.includes("in")) return x;
    if(u.includes("mm")) return x / 25.4;
    if(u.includes("m")) return x * 39.3701;
    return x; // assume inches
  }

  // Burn window filter (local America/New_York by default from NWS points timeZone)
  function localHM(tMs, timeZone){
    const d = new Date(tMs);
    const parts = new Intl.DateTimeFormat("en-US", { timeZone, hour:"2-digit", minute:"2-digit", hour12:false }).formatToParts(d);
    const hh = Number(parts.find(p=>p.type==="hour")?.value ?? "0");
    const mm = Number(parts.find(p=>p.type==="minute")?.value ?? "0");
    return hh*60 + mm;
  }

  function inBurnWindow(tMs, timeZone, startMin, endMin){
    const hm = localHM(tMs, timeZone);
    if(startMin === endMin) return true;
    if(startMin < endMin){
      return hm >= startMin && hm < endMin;
    }
    // overnight window (rare): e.g. 18:00–09:00
    return hm >= startMin || hm < endMin;
  }

  function withinNextHours(tMs, startMs, hours){
    return tMs >= startMs && tMs < (startMs + hours*3600*1000);
  }

  // ---------- Core evaluation ----------
  async function evaluateGeoJSON(geojson, settings){
    if(aborter) aborter.abort();
    aborter = new AbortController();

    setMode("Fetching weather…");
    setStatus("Parsing GeoJSON…");
    clearCards();
    lastResults = null;
    lastRanked = null;

    const fc = normalizeFeatureCollection(geojson);
    if(!fc){
      toast(`<strong>Bad GeoJSON.</strong> Needs a FeatureCollection.`, 3500);
      setMode("Error");
      setStatus("Invalid GeoJSON.");
      return;
    }

    const burnStartMin = parseHHMM(settings.burnStart) ?? parseHHMM("09:00");
    const burnEndMin   = parseHHMM(settings.burnEnd) ?? parseHHMM("18:00");

    // Build unit list
    const units = [];
    for(let i=0;i<fc.features.length;i++){
      const f = fc.features[i];
      const geom = f?.geometry;
      const props = f?.properties || {};
      const cent = centroidOfGeometry(geom);
      const unitId = getUnitId(props, i);
      const tract = getTract(props);
      const tractOk = !!tract;

      const crsOk = cent && isLonLatPlausible(cent.lon, cent.lat);
      units.push({
        i, feature: f,
        unitId, tract,
        centroid: cent,
        crsOk,
        tractOk,
        props
      });
    }

    const preferTractCorrectness = settings.preferTractCorrectness;
    const candidates = units.filter(u => u.crsOk && (!preferTractCorrectness || u.tractOk));

    if(candidates.length === 0){
      toast(`<strong>No usable polygons.</strong> Check CRS (must be lon/lat) and tract property.`, 4500);
      setMode("Error");
      setStatus("No usable features (CRS/tract).");
      return;
    }

    setStatus(`Found ${candidates.length} usable unit(s). Fetching NWS grid + station…`);

    // Evaluate each candidate (with limited parallelism)
    const evaluated = [];
    const concurrency = 4;
    let idx = 0;

    async function worker(){
      while(idx < candidates.length){
        const u = candidates[idx++];
        const res = await evaluateUnit(u, settings, burnStartMin, burnEndMin);
        evaluated.push(res);
        setStatus(`Evaluated ${evaluated.length}/${candidates.length} units…`);
      }
    }
    await Promise.all(Array.from({length: concurrency}, worker));

    // Rank and render
    lastResults = evaluated;

    const ranked = rankBestByTract(evaluated, settings);
    lastRanked = ranked;

    renderCards(ranked, settings);
    setMode("Done");
    setStatus(`Showing best ${ranked.length} tract(s) (one top unit each).`);

    // Save settings
    writeSettings();
    updatePills();
  }

  function normalizeFeatureCollection(x){
    if(!x) return null;
    if(x.type === "FeatureCollection" && Array.isArray(x.features)) return x;
    // If user drops a single Feature
    if(x.type === "Feature" && x.geometry){
      return { type:"FeatureCollection", features:[x] };
    }
    return null;
  }

  async function evaluateUnit(u, settings, burnStartMin, burnEndMin){
    const { centroid } = u;
    const lat = centroid.lat;
    const lon = centroid.lon;

    const ptUrl = `https://api.weather.gov/points/${lat.toFixed(5)},${lon.toFixed(5)}`;
    const pt = await fetchJson(ptUrl, settings, "points");

    if(!pt.ok){
      return makeResult(u, settings, { source: pt.source, error: `points fetch failed: ${pt.error}` });
    }

    const props = pt.data?.properties || {};
    const timeZone = props.timeZone || "America/New_York"; // Florida default
    const gridUrl = props.forecastGridData;
    const stationsUrl = props.observationStations;

    if(!gridUrl){
      return makeResult(u, settings, { source: pt.source, timeZone, error: "Missing forecastGridData in points response" });
    }

    // grid
    const grid = await fetchJson(gridUrl, settings, "grid");
    if(!grid.ok){
      return makeResult(u, settings, { source: grid.source, timeZone, error: `grid fetch failed: ${grid.error}` });
    }

    const gridProps = grid.data?.properties || {};
    const missing = REQUIRED_GRID_FIELDS.filter(k => !gridProps[k]?.values);
    // We'll allow missing precip + gust sometimes, but conservatively mark unknown
    const hasRH = !!gridProps.relativeHumidity?.values;
    const hasWind = !!gridProps.windSpeed?.values;
    const hasGust = !!gridProps.windGust?.values;
    const hasMix = !!gridProps.mixingHeight?.values;
    const hasQpf = !!gridProps.quantitativePrecipitation?.values;

    // Expand to hourly (next 24h)
    const startMs = Date.now();
    const next24h = 24;

    // RH (daytime window)
    let rhSeries = hasRH ? expandToHourly(gridProps.relativeHumidity.values) : [];
    rhSeries = rhSeries.filter(p => withinNextHours(p.t, startMs, next24h) && inBurnWindow(p.t, timeZone, burnStartMin, burnEndMin));
    const rhVals = rhSeries.map(p => Number(p.v)).filter(v => Number.isFinite(v));

    // Mixing height (daytime window)
    let mixSeries = hasMix ? expandToHourly(gridProps.mixingHeight.values) : [];
    const mixUnit = gridProps.mixingHeight?.uom || "";
    mixSeries = mixSeries
      .filter(p => withinNextHours(p.t, startMs, next24h) && inBurnWindow(p.t, timeZone, burnStartMin, burnEndMin))
      .map(p => ({ t:p.t, v: convertLengthToFeet(Number(p.v), mixUnit) }))
      .filter(p => Number.isFinite(p.v));
    const mixVals = mixSeries.map(p => p.v);

    // Wind & Gust
    const windWindowed = !!settings.windowForWind;
    let windSeries = hasWind ? expandToHourly(gridProps.windSpeed.values) : [];
    const windUnit = gridProps.windSpeed?.uom || "";
    windSeries = windSeries
      .filter(p => withinNextHours(p.t, startMs, next24h) && (!windWindowed || inBurnWindow(p.t, timeZone, burnStartMin, burnEndMin)))
      .map(p => ({t:p.t, v: convertSpeedToMph(Number(p.v), windUnit)}))
      .filter(p => Number.isFinite(p.v));
    const windMax = windSeries.length ? Math.max(...windSeries.map(p=>p.v)) : null;

    let gustSeries = hasGust ? expandToHourly(gridProps.windGust.values) : [];
    const gustUnit = gridProps.windGust?.uom || "";
    gustSeries = gustSeries
      .filter(p => withinNextHours(p.t, startMs, next24h) && (!windWindowed || inBurnWindow(p.t, timeZone, burnStartMin, burnEndMin)))
      .map(p => ({t:p.t, v: convertSpeedToMph(Number(p.v), gustUnit)}))
      .filter(p => Number.isFinite(p.v));
    const gustMax = gustSeries.length ? Math.max(...gustSeries.map(p=>p.v)) : null;

    // QPF
    const qpfWindowed = !!settings.windowForQpf;
    let qpfSeries = hasQpf ? expandToHourly(gridProps.quantitativePrecipitation.values) : [];
    const qpfUnit = gridProps.quantitativePrecipitation?.uom || "";
    qpfSeries = qpfSeries
      .filter(p => withinNextHours(p.t, startMs, next24h) && (!qpfWindowed || inBurnWindow(p.t, timeZone, burnStartMin, burnEndMin)))
      .map(p => ({t:p.t, v: convertPrecipToInches(Number(p.v), qpfUnit)}))
      .filter(p => Number.isFinite(p.v));
    const qpfSum = qpfSeries.length ? qpfSeries.reduce((a,b)=>a+b.v, 0) : null;

    // Last rain via station observations
    let lastRain = { label:"—", stationId:null, ok:false, source:"", note:"" };
    if(stationsUrl){
      lastRain = await computeLastRain(stationsUrl, settings, timeZone);
    } else {
      lastRain = { label:"—", stationId:null, ok:false, source:"", note:"No observationStations URL" };
    }

    // Daytime RH range
    const rhMin = rhVals.length ? Math.min(...rhVals) : null;
    const rhMax = rhVals.length ? Math.max(...rhVals) : null;

    // DAYTIME min mixing height
    const mixMin = mixVals.length ? Math.min(...mixVals) : null;

    // Hard decision thresholds
    const rhGoMin = settings.rhGoMin;
    const rhGoMax = settings.rhGoMax;
    const windMaxThr = settings.windMax;
    const gustMaxThr = settings.gustMax;
    const mixMinThr = settings.mixMinFt;
    const qpfSumMaxThr = settings.qpfSumMaxIn;

    // Required-data rules (conservative)
    const requiredOk =
      (rhVals.length > 0) &&
      (mixVals.length > 0) &&
      (windMax !== null) &&
      (gustMax !== null) &&
      (qpfSum !== null);

    const missingReason = [];
    if(rhVals.length === 0) missingReason.push("no daytime RH");
    if(mixVals.length === 0) missingReason.push("no daytime mixing height");
    if(windMax === null) missingReason.push("no wind speed");
    if(gustMax === null) missingReason.push("no wind gust");
    if(qpfSum === null) missingReason.push("no QPF");

    let decision = "NO-GO";
    let reason = "";
    if(!requiredOk){
      decision = "NO-GO";
      reason = "Data unknown: " + missingReason.join(", ");
    } else {
      // GO checks
      const rhOk = (rhMin >= rhGoMin && rhMax <= rhGoMax);
      const windOk = (windMax <= windMaxThr);
      const gustOk = (gustMax <= gustMaxThr);
      const mixOk = (mixMin >= mixMinThr);
      const qpfOk = (qpfSum <= qpfSumMaxThr);

      // CAUTION bands (soft)
      const rhCaution = (!rhOk && ( (rhMin >= rhGoMin-5 && rhMin < rhGoMin) || (rhMax > rhGoMax && rhMax <= rhGoMax+5) ));
      const windCaution = (windMax > windMaxThr && windMax <= windMaxThr + 3);
      const gustCaution = (gustMax > gustMaxThr && gustMax <= gustMaxThr + 5);
      const mixCaution = (mixMin < mixMinThr && mixMin >= mixMinThr - 500);
      const qpfCaution = (qpfSum > qpfSumMaxThr && qpfSum <= qpfSumMaxThr + 0.10);

      const anyHardNo =
        (rhMin < rhGoMin-5) ||
        (rhMax > rhGoMax+5) ||
        (windMax > windMaxThr + 3) ||
        (gustMax > gustMaxThr + 5) ||
        (mixMin < mixMinThr - 500) ||
        (qpfSum > qpfSumMaxThr + 0.10);

      if(anyHardNo){
        decision = "NO-GO";
        reason = "Out of bounds";
      } else if(rhOk && windOk && gustOk && mixOk && qpfOk){
        decision = "GO";
        reason = "Within GO envelope";
      } else if(rhCaution || windCaution || gustCaution || mixCaution || qpfCaution){
        decision = "CAUTION";
        reason = "Marginal in at least one parameter";
      } else {
        // Conservative fallback
        decision = "NO-GO";
        reason = "Conservative NO-GO (non-GO conditions)";
      }
    }

    // Score (0–100) — “best tracts” ranking
    const score = computeScore({
      rhMin, rhMax, windMax, gustMax, mixMin, qpfSum, lastRainHoursAgo: lastRain.hoursAgo,
      decision
    }, settings);

    // Source rollup
    const source = pickSource(pt.source, grid.source, lastRain.source);

    return makeResult(u, settings, {
      source,
      timeZone,
      decision,
      reason,
      rhMin, rhMax,
      windMax, gustMax,
      mixMin,
      qpfSum,
      lastRain,
      requiredOk,
      missingReason,
      gridMissing: missing,
      burnWindow: { start: settings.burnStart, end: settings.burnEnd },
      score
    });
  }

  function pickSource(...sources){
    // If any OFFLINE => OFFLINE, else if any LIVE => LIVE else CACHED
    if(sources.includes("OFFLINE")) return "OFFLINE";
    if(sources.includes("LIVE")) return "LIVE";
    return "CACHED";
  }

  function makeResult(u, settings, data){
    return {
      unitId: u.unitId,
      tract: u.tract,
      centroid: u.centroid,
      crsOk: u.crsOk,
      tractOk: u.tractOk,
      props: u.props,
      featureIndex: u.i,
      ...data
    };
  }

  async function computeLastRain(stationsUrl, settings, timeZone){
    // 1) fetch station list -> choose first station ID
    const st = await fetchJson(stationsUrl, settings, "stations");
    if(!st.ok){
      return { label:"—", stationId:null, ok:false, source:st.source, note:`stations fetch failed: ${st.error}` };
    }
    const stations = st.data?.features || [];
    const firstId = stations?.[0]?.properties?.stationIdentifier || stations?.[0]?.id?.split("/").pop() || null;
    if(!firstId){
      return { label:"—", stationId:null, ok:false, source:st.source, note:"No stationIdentifier found" };
    }

    // 2) fetch observations (last 24h-ish)
    const obsUrl = `https://api.weather.gov/stations/${firstId}/observations?limit=50`;
    const ob = await fetchJson(obsUrl, settings, "obs");
    if(!ob.ok){
      return { label:"—", stationId:firstId, ok:false, source:ob.source, note:`observations fetch failed: ${ob.error}` };
    }

    const feats = ob.data?.features || [];
    // Find most recent precip > 0 (precipitationLastHour) OR fallback to precipitationLast3Hours/6Hours if present
    let best = null; // {tMs, amountIn, field}
    let hasAnyPrecipField = false;

    for(const f of feats){
      const p = f?.properties;
      if(!p) continue;
      const tMs = Date.parse(p.timestamp);
      if(Number.isNaN(tMs)) continue;

      const fields = [
        ["precipitationLastHour", 1],
        ["precipitationLast3Hours", 3],
        ["precipitationLast6Hours", 6]
      ];

      for(const [field, hours] of fields){
        const q = p[field];
        if(q && q.value !== null && q.value !== undefined){
          hasAnyPrecipField = true;
          const amountIn = convertPrecipToInches(Number(q.value), q.unitCode || q.unit || "wmoUnit:mm");
          if(Number.isFinite(amountIn) && amountIn > 0){
            if(!best || tMs > best.tMs){
              best = { tMs, amountIn, field, windowH: hours };
            }
          }
        }
      }
    }

    if(!hasAnyPrecipField){
      return { label:"no precip field (station)", stationId:firstId, ok:false, source:ob.source, note:"Station observations lacked precip fields" };
    }

    if(!best){
      return { label:"no measurable rain in last 24h", stationId:firstId, ok:true, source:ob.source, hoursAgo:null, note:"" };
    }

    const hrsAgo = (Date.now() - best.tMs) / 3600000;
    const dtLocal = new Intl.DateTimeFormat("en-US", {
      timeZone: (timeZone || "America/New_York"),
      year:"numeric", month:"2-digit", day:"2-digit",
      hour:"2-digit", minute:"2-digit", hour12:true
    }).format(new Date(best.tMs));

    return {
      label: `${fmt(best.amountIn,2)} in @ ${dtLocal}`,
      stationId: firstId,
      ok: true,
      source: ob.source,
      hoursAgo: hrsAgo,
      note: `from ${best.field}`
    };
  }

  function computeScore(metrics, settings){
    // 0–100, higher is better. Uses soft penalties and weights.
    // Decision still uses thresholds.
    let score = 100;

    const wRh = settings.wRh;
    const wWind = settings.wWind;
    const wMix = settings.wMix;
    const wRain = settings.wRain;

    // If NO-GO due to missing data => very low score
    if(metrics.decision === "NO-GO" && (
      metrics.rhMin === null || metrics.rhMax === null ||
      metrics.windMax === null || metrics.gustMax === null ||
      metrics.mixMin === null || metrics.qpfSum === null
    )){
      return 0;
    }

    // RH penalty: prefer within GO envelope, penalize outside
    const rhMin = metrics.rhMin, rhMax = metrics.rhMax;
    if(rhMin !== null && rhMax !== null){
      const lo = settings.rhGoMin, hi = settings.rhGoMax;
      let pen = 0;
      if(rhMin < lo) pen += (lo - rhMin) * 1.2;
      if(rhMax > hi) pen += (rhMax - hi) * 1.0;
      score -= wRh * pen;
    }

    // Wind penalty
    if(metrics.windMax !== null){
      const thr = settings.windMax;
      const over = Math.max(0, metrics.windMax - thr);
      score -= wWind * over * 2.4;
    }
    if(metrics.gustMax !== null){
      const thr = settings.gustMax;
      const over = Math.max(0, metrics.gustMax - thr);
      score -= wWind * over * 1.6;
    }

    // Mixing penalty: below threshold hurts more; above threshold slight benefit
    if(metrics.mixMin !== null){
      const thr = settings.mixMinFt;
      if(metrics.mixMin < thr){
        score -= wMix * (thr - metrics.mixMin) * 0.03; // 1000 ft below => -66 at wMix=2.2
      } else {
        score += wMix * Math.min(20, (metrics.mixMin - thr) * 0.004);
      }
    }

    // Rain / QPF penalty
    if(metrics.qpfSum !== null){
      const thr = settings.qpfSumMaxIn;
      const over = Math.max(0, metrics.qpfSum - thr);
      score -= wRain * over * 280; // 0.10 over => -28 at wRain=1
    }

    // Last-rain tweak (optional): if rain occurred very recently, penalize a bit (fuel moisture/holding)
    if(metrics.lastRainHoursAgo !== null && metrics.lastRainHoursAgo !== undefined){
      const h = metrics.lastRainHoursAgo;
      if(Number.isFinite(h)){
        // very recent rain (<6h) penalty; older rain minimal
        const pen = h < 6 ? (6 - h) * 2.0 : 0;
        score -= wRain * pen;
      }
    }

    // Decision nudge
    if(metrics.decision === "GO") score += 8;
    if(metrics.decision === "CAUTION") score -= 8;
    if(metrics.decision === "NO-GO") score -= 18;

    return Math.round(clamp(score, 0, 100));
  }

  function rankBestByTract(evaluated, settings){
    const skipUnknown = settings.skipUnknownData;
    const topN = clamp(Number(settings.topLimit||10), 1, 50);

    // group by tract
    const byTract = new Map();
    for(const r of evaluated){
      const tract = r.tract;
      if(!tract) continue;

      const usable = !!r.requiredOk && r.decision !== "NO-GO" ? true : (!!r.requiredOk); // still allow NO-GO if requiredOk
      const unknown = !r.requiredOk;

      if(skipUnknown && unknown) continue;

      if(!byTract.has(tract)) byTract.set(tract, []);
      byTract.get(tract).push(r);
    }

    // choose best unit per tract by highest score, then decision priority, then higher mixing, lower wind, etc.
    const best = [];
    for(const [tract, list] of byTract.entries()){
      if(!list.length) continue;

      list.sort((a,b)=>{
        // score desc
        if(b.score !== a.score) return b.score - a.score;

        // decision priority: GO > CAUTION > NO-GO
        const pr = (d)=> d==="GO" ? 2 : d==="CAUTION" ? 1 : 0;
        if(pr(b.decision) !== pr(a.decision)) return pr(b.decision) - pr(a.decision);

        // higher daytime mixing min better
        const am = a.mixMin ?? -Infinity, bm = b.mixMin ?? -Infinity;
        if(bm !== am) return bm - am;

        // lower wind/gust better
        const aw = a.windMax ?? Infinity, bw = b.windMax ?? Infinity;
        if(aw !== bw) return aw - bw;

        const ag = a.gustMax ?? Infinity, bg = b.gustMax ?? Infinity;
        if(ag !== bg) return ag - bg;

        // lower QPF better
        const aq = a.qpfSum ?? Infinity, bq = b.qpfSum ?? Infinity;
        if(aq !== bq) return aq - bq;

        return 0;
      });

      // “If none exist → skip to next tract”
      // Interpreting as: if no unit has requiredOk, skip tract (already filtered by skipUnknown).
      const pick = list[0];
      if(skipUnknown && !pick.requiredOk) continue;

      best.push(pick);
    }

    best.sort((a,b)=> b.score - a.score);
    return best.slice(0, topN);
  }

  // ---------- Render ----------
  function renderCards(ranked, settings){
    clearCards();

    if(!ranked.length){
      cardsEl.innerHTML = `<div class="card"><div class="title">No ranked tracts</div><div class="sub">Either all units were missing required data, or tract names/CRS were invalid.</div></div>`;
      return;
    }

    for(const r of ranked){
      const decision = r.decision || "NO-GO";
      const badgeClass = decision === "GO" ? "b-go" : (decision === "CAUTION" ? "b-caution" : "b-nogo");

      const tz = r.timeZone || "America/New_York";
      const burn = r.burnWindow ? `${r.burnWindow.start}–${r.burnWindow.end}` : `${settings.burnStart}–${settings.burnEnd}`;

      const rhRange = (r.rhMin !== null && r.rhMax !== null) ? `${fmt(r.rhMin,0)}–${fmt(r.rhMax,0)}%` : "—";
      const wind = (r.windMax !== null) ? `${fmt(r.windMax,1)} mph` : "—";
      const gust = (r.gustMax !== null) ? `${fmt(r.gustMax,1)} mph` : "—";
      const mix = (r.mixMin !== null) ? `${fmt(r.mixMin,0)} ft` : "—";
      const qpf = (r.qpfSum !== null) ? `${fmt(r.qpfSum,2)} in` : "—";

      const lat = r.centroid?.lat, lon = r.centroid?.lon;
      const centroidStr = (lat!==null && lon!==null) ? `${fmt(lat,5)}, ${fmt(lon,5)}` : "—";

      const lastRain = r.lastRain?.label || "—";
      const lastRainNote = r.lastRain?.note ? ` (${r.lastRain.note})` : "";
      const src = r.source || "—";

      const reason = r.reason ? r.reason : "";

      const score = (r.score ?? 0);
      const fill = `${clamp(score,0,100)}%`;

      const tract = r.tract || "Unknown tract";
      const unitTitle = `${r.unitId} · Tract ${tract}`;

      const missing = (r.gridMissing && r.gridMissing.length) ? `Missing fields: ${r.gridMissing.join(", ")}` : "";
      const dataWarn = (!r.requiredOk) ? `Data unknown → conservative NO-GO` : "";

      const card = document.createElement("div");
      card.className = "card";
      card.innerHTML = `
        <div class="cardHead">
          <div>
            <div class="title">${escapeHtml(unitTitle)}</div>
            <div class="sub">${escapeHtml(reason)} · Burn window <strong>${escapeHtml(burn)}</strong> · TZ ${escapeHtml(tz)}</div>
          </div>
          <div class="badge ${badgeClass}">${escapeHtml(decision)}</div>
        </div>

        <div class="kv">
          <div class="k">Centroid</div><div class="v">${escapeHtml(centroidStr)}</div>

          <div class="k">RH daytime (${escapeHtml(burn)})</div><div class="v">${escapeHtml(rhRange)}</div>
          <div class="k">Wind max</div><div class="v">${escapeHtml(wind)}</div>
          <div class="k">Gust max</div><div class="v">${escapeHtml(gust)}</div>

          <div class="k">Mixing height <strong>DAYTIME min</strong></div><div class="v">${escapeHtml(mix)}</div>

          <div class="k">QPF next 24h sum</div><div class="v">${escapeHtml(qpf)}</div>
          <div class="k">Last rain (station)</div><div class="v">${escapeHtml(lastRain)}${escapeHtml(lastRainNote)}</div>

          ${(missing || dataWarn) ? `<div class="muted">${escapeHtml([dataWarn, missing].filter(Boolean).join(" · "))}</div>` : ``}
        </div>

        <div class="scoreRow">
          <div>Burn Quality Score</div>
          <div><strong style="color:#fff">${escapeHtml(String(score))}%</strong></div>
        </div>
        <div class="bar"><div class="fill" style="width:${fill}"></div></div>

        <div class="foot">
          Source: <code>api.weather.gov</code> (${escapeHtml(src)}; grid + nearest station)
        </div>
      `;
      cardsEl.appendChild(card);
    }
  }

  function escapeHtml(s){
    return String(s)
      .replaceAll("&","&amp;")
      .replaceAll("<","&lt;")
      .replaceAll(">","&gt;")
      .replaceAll('"',"&quot;")
      .replaceAll("'","&#039;");
  }

  // ---------- Demo data ----------
  function demoGeoJSON(){
    // Simple demo polygons around Citrus/Homosassa-ish; replace with your real GeoJSON upload.
    return {
      "type":"FeatureCollection",
      "features":[
        {"type":"Feature","properties":{"Ident":"CI29","Tract":"Citrus"},"geometry":{"type":"Polygon","coordinates":[[[-82.515,28.71],[-82.50,28.71],[-82.50,28.72],[-82.515,28.72],[-82.515,28.71]]]}},
        {"type":"Feature","properties":{"Ident":"CI30","Tract":"Citrus"},"geometry":{"type":"Polygon","coordinates":[[[-82.495,28.69],[-82.48,28.69],[-82.48,28.70],[-82.495,28.70],[-82.495,28.69]]]}},
        {"type":"Feature","properties":{"Ident":"HT03","Tract":"Homosassa"},"geometry":{"type":"Polygon","coordinates":[[[-82.58,28.73],[-82.56,28.73],[-82.56,28.75],[-82.58,28.75],[-82.58,28.73]]]}},
        {"type":"Feature","properties":{"Ident":"RI06","Tract":"Richloam"},"geometry":{"type":"Polygon","coordinates":[[[-82.14,28.52],[-82.11,28.52],[-82.11,28.54],[-82.14,28.54],[-82.14,28.52]]]}},
        {"type":"Feature","properties":{"Ident":"JC01","Tract":"Jumper Creek"},"geometry":{"type":"Polygon","coordinates":[[[-82.19,28.75],[-82.17,28.75],[-82.17,28.77],[-82.19,28.77],[-82.19,28.75]]]}}
      ]
    };
  }

  // ---------- Events ----------
  function wire(){
    // Load persisted settings
    applySettings(readSettings() || null);

    // Update pills initially
    updatePills();

    // Save settings on change
    const inputs = [
      burnStartEl,burnEndEl,topLimitEl,cacheTtlHEl,
      rhGoMinEl,rhGoMaxEl,windMaxEl,gustMaxEl,mixMinFtEl,qpfSumMaxInEl,
      windowForWindEl,windowForQpfEl,windowForLastRainEl,
      wRhEl,wWindEl,wMixEl,wRainEl,
      preferTractCorrectnessEl,skipUnknownDataEl
    ];
    inputs.forEach(inp => inp.addEventListener("change", ()=>{
      updatePills();
      writeSettings();
    }));

    // Drop zone click
    dropZone.addEventListener("click", () => fileInput.click());
    dropZone.addEventListener("keydown", (e)=>{ if(e.key==="Enter"||e.key===" "){ e.preventDefault(); fileInput.click(); } });

    // Drag & drop
    dropZone.addEventListener("dragover", (e)=>{ e.preventDefault(); dropZone.style.borderColor="#ffffff66"; });
    dropZone.addEventListener("dragleave", ()=>{ dropZone.style.borderColor=""; });
    dropZone.addEventListener("drop", (e)=>{
      e.preventDefault();
      dropZone.style.borderColor="";
      const f = e.dataTransfer.files?.[0];
      if(f) handleFile(f);
    });

    fileInput.addEventListener("change", ()=>{
      const f = fileInput.files?.[0];
      if(f) handleFile(f);
      fileInput.value = "";
    });

    btnRunDemo.addEventListener("click", async ()=>{
      const settings = getSettings();
      lastGeojson = demoGeoJSON();
      toast(`<strong>Demo loaded.</strong> Fetching NWS grid… <span class="muted">(this can take a bit)</span>`, 2500);
      await evaluateGeoJSON(lastGeojson, settings);
    });

    btnClear.addEventListener("click", ()=>{
      if(aborter) aborter.abort();
      lastGeojson = null;
      lastResults = null;
      lastRanked = null;
      clearCards();
      setMode("Ready");
      setStatus("Cleared. Drop a GeoJSON to begin.");
      toast(`<strong>Cleared.</strong>`, 1500);
    });

    btnReRank.addEventListener("click", ()=>{
      if(!lastResults){
        toast(`<strong>Nothing to re-rank.</strong> Upload or load demo first.`, 2200);
        return;
      }
      const settings = getSettings();
      const ranked = rankBestByTract(lastResults, settings);
      lastRanked = ranked;
      renderCards(ranked, settings);
      setMode("Re-ranked");
      setStatus(`Re-ranked using current settings. Showing ${ranked.length} tract(s).`);
      writeSettings();
      updatePills();
    });

    btnExport.addEventListener("click", ()=>{
      if(!lastRanked){
        toast(`<strong>Nothing to export.</strong>`, 1800);
        return;
      }
      const out = {
        generatedAt: new Date().toISOString(),
        settings: getSettings(),
        rankedTracts: lastRanked.map(r => ({
          unitId: r.unitId,
          tract: r.tract,
          centroid: r.centroid,
          decision: r.decision,
          score: r.score,
          rhDaytimeMin: r.rhMin,
          rhDaytimeMax: r.rhMax,
          windMax: r.windMax,
          gustMax: r.gustMax,
          mixingDaytimeMinFt: r.mixMin,
          qpfNext24hSumIn: r.qpfSum,
          lastRain: r.lastRain
        }))
      };
      const blob = new Blob([JSON.stringify(out, null, 2)], {type:"application/json"});
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "rxboss_ranked.json";
      a.click();
      URL.revokeObjectURL(url);
      toast(`<strong>Exported.</strong> rxboss_ranked.json`, 2000);
    });
  }

  async function handleFile(file){
    try{
      setMode("Loading file…");
      setStatus(`Reading ${file.name}…`);
      const text = await file.text();
      const json = JSON.parse(text);
      lastGeojson = json;
      const settings = getSettings();
      toast(`<strong>Loaded:</strong> ${escapeHtml(file.name)} · Fetching NWS…`, 2200);
      await evaluateGeoJSON(json, settings);
    }catch(e){
      setMode("Error");
      setStatus("Failed to load file.");
      toast(`<strong>Could not read JSON.</strong> <span class="muted">${escapeHtml(String(e))}</span>`, 4200);
    }
  }

  // ---------- Boot ----------
  wire();
})();
</script>
</body>
</html>
