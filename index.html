<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>RX Boss ‚Äî Florida Prescribed Burn GO / NO-GO</title>
  <style>
    :root{
      /* üî• Fire / red theme */
      --bg:#12060a;
      --panel:#1a0b10;
      --panel2:#14080d;
      --text:#ffeef2;
      --muted:#f3b7c2;
      --line:rgba(255,255,255,.10);

      /* keep variable name so we don‚Äôt rewrite CSS selectors */
      --blue:#fb7185;

      --green:#34d399;
      --amber:#fbbf24;
      --red:#fb7185;

      --pill:#12060a;
      --shadow: 0 20px 60px rgba(0,0,0,.45);
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background:
        radial-gradient(1200px 700px at 30% 10%, rgba(251,113,133,.22), transparent 60%),
        radial-gradient(900px 650px at 80% 20%, rgba(255,120,80,.14), transparent 55%),
        linear-gradient(180deg, #050206, var(--bg));
      color:var(--text);
      min-height:100vh;
    }
    .wrap{max-width:1200px;margin:0 auto;padding:28px 18px 40px}
    h1{margin:0 0 6px;font-size:44px;letter-spacing:-.02em;color:var(--blue)}
    .subtitle{margin:0 0 16px;color:var(--muted)}
    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(0,0,0,.12));
      border:1px solid var(--line);
      border-radius:18px;
      box-shadow:var(--shadow);
      padding:16px;
    }
    .topGrid{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:14px;
    }
    @media (max-width: 980px){ .topGrid{grid-template-columns:1fr} }
    .drop{
      border:2px dashed rgba(255,255,255,.18);
      border-radius:16px;
      padding:22px;
      text-align:center;
      background: rgba(0,0,0,.20);
      cursor:pointer;
      user-select:none;
      transition:.15s ease;
    }
    .drop:hover{border-color:rgba(251,113,133,.55)}
    .drop strong{font-size:18px}
    .small{color:var(--muted);font-size:13px;margin-top:8px}
    .row{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
    button{
      background:rgba(255,255,255,.06);
      border:1px solid var(--line);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      font-weight:600;
    }
    button:hover{border-color:rgba(251,113,133,.45)}
    .pill{
      display:inline-flex;gap:8px;align-items:center;
      padding:8px 10px;border-radius:999px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.18);
      color:var(--muted);
      font-size:13px;
    }
    .pill b{color:var(--text);font-weight:700}
    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .ctrl{
      padding:12px;
      border:1px solid var(--line);
      border-radius:14px;
      background: rgba(0,0,0,.14);
    }
    .ctrl h3{margin:0 0 8px;font-size:14px;color:var(--text)}
    .ctrl label{display:flex;justify-content:space-between;gap:10px;align-items:center;margin:8px 0;color:var(--muted);font-size:13px}
    .ctrl input[type="number"]{
      width:120px;
      background:rgba(255,255,255,.06);
      border:1px solid var(--line);
      color:var(--text);
      border-radius:10px;
      padding:7px 8px;
    }
    .ctrl input[type="checkbox"]{transform:scale(1.15)}
    .cards{
      margin-top:16px;
      display:grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap:12px;
    }
    @media (max-width: 1100px){.cards{grid-template-columns:repeat(2,1fr)}}
    @media (max-width: 720px){.cards{grid-template-columns:1fr}}
    .card{
      border:1px solid var(--line);
      border-radius:16px;
      padding:12px 12px 10px;
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(0,0,0,.16));
      position:relative;
      overflow:hidden;
    }
    .cardHeader{display:flex;align-items:flex-start;justify-content:space-between;gap:10px}
    .title{font-size:16px;font-weight:800;letter-spacing:.01em;margin:0;}
    .tag{
      padding:4px 10px;border-radius:999px;border:1px solid var(--line);
      font-size:12px;font-weight:800;letter-spacing:.02em;
    }
    .tag.ready{color:var(--green);border-color:rgba(52,211,153,.35);background:rgba(52,211,153,.08)}
    .tag.caution{color:var(--amber);border-color:rgba(251,191,36,.35);background:rgba(251,191,36,.08)}
    .tag.nogo{color:var(--red);border-color:rgba(251,113,133,.35);background:rgba(251,113,133,.08)}
    .kv{margin-top:8px;color:var(--muted);font-size:13px;line-height:1.25}
    .kv code{color:var(--text);background:rgba(0,0,0,.22);padding:2px 6px;border-radius:8px;border:1px solid var(--line)}
    .kv .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}
    .sep{height:1px;background:var(--line);margin:10px 0}
    .scoreLine{display:flex;justify-content:space-between;align-items:center;color:var(--muted);font-size:12px}
    .bar{height:8px;background:rgba(255,255,255,.08);border:1px solid var(--line);border-radius:999px;overflow:hidden;margin-top:6px}
    .bar > div{height:100%;background:rgba(251,113,133,.80)}
    .warn{color:var(--muted);font-size:12px;margin-top:8px}
    .footerNote{margin-top:14px;color:var(--muted);font-size:12px}
    a{color:var(--blue)}
  </style>
</head>

<body>
  <div class="wrap">
    <h1>RX Boss</h1>
    <p class="subtitle">
      Florida Prescribed Burn GO / NO-GO Decision Tool ‚Äî ranks the <b>best burn candidates</b> by weather + rainfall signal.
      <span class="mono" style="opacity:.9">RH uses DAYTIME only</span>.
    </p>

    <div class="topGrid">
      <div class="panel">
        <div id="drop" class="drop" tabindex="0">
          <strong>Drop GeoJSON burn units here</strong> <span class="small">(or click to select)</span>
          <div class="small">Accepts <b>.geojson</b> or <b>.json</b> FeatureCollections. Needs polygons. Must include a <b>Tract</b> field (any case). If none exist ‚Üí skipped.</div>
        </div>

        <div class="row">
          <button id="btnClear">Clear</button>
          <button id="btnDemo">Load demo data</button>
          <span class="pill"><b>Status:</b> <span id="status">Waiting for GeoJSON‚Ä¶</span></span>
          <span class="pill"><b>Output:</b> Top <span id="topNLabel">10</span> candidates</span>
        </div>

        <div class="footerNote">
          Uses NWS API: grid forecast (next 24h) + nearest station precip. Rain includes <b>last 24 hours</b> when the station reports it.
        </div>
      </div>

      <div class="panel">
        <div class="controls">
          <div class="ctrl">
            <h3>GO / CAUTION / NO-GO thresholds</h3>

            <label>RH GO band (DAYTIME %) <span>
              <input id="rhGoMin" type="number" value="30" /> ‚Äì
              <input id="rhGoMax" type="number" value="55" />
            </span></label>

            <label>RH hard NO-GO (DAYTIME <span class="mono">&lt;</span> / <span class="mono">&gt;</span>) <span>
              <input id="rhNoGoLow" type="number" value="25" /> /
              <input id="rhNoGoHigh" type="number" value="60" />
            </span></label>

            <label>Wind sustained max (mph) <input id="windMax" type="number" value="18" /></label>
            <label>Gust max (mph) <input id="gustMax" type="number" value="25" /></label>
            <label>Mixing height min (ft) <input id="mixMin" type="number" value="1200" /></label>
            <label>QPF next 24h max (in) <input id="qpfMax" type="number" value="0.10" step="0.01" /></label>

            <label>Rain last 24h hard NO-GO (in) <input id="rain24NoGo" type="number" value="0.25" step="0.01" /></label>
          </div>

          <div class="ctrl">
            <h3>Ranking & display</h3>
            <label>Show top N <input id="topN" type="number" value="10" min="1" max="50" /></label>
            <label>Include NO-GO in list <input id="includeNoGo" type="checkbox" /></label>
            <label>Penalize rain last 24h <input id="rain24Penalty" type="checkbox" checked /></label>
            <label>Use QPF (forecast) in scoring <input id="useQpfScore" type="checkbox" checked /></label>
            <button id="btnRecalc">Recalculate</button>
            <div class="small">Daytime window: <b>9AM‚Äì6PM local</b> (NWS point timezone). Change in code if you want.</div>
          </div>
        </div>
      </div>
    </div>

    <div id="cards" class="cards"></div>
  </div>

<script>
/* ---------------------------
   RX Boss ‚Äî GitHub Pages build
   Daytime RH + Last-24h Rain + Fire Theme
   --------------------------- */

const UI = {
  drop: document.getElementById('drop'),
  status: document.getElementById('status'),
  cards: document.getElementById('cards'),
  btnClear: document.getElementById('btnClear'),
  btnDemo: document.getElementById('btnDemo'),
  btnRecalc: document.getElementById('btnRecalc'),
  topN: document.getElementById('topN'),
  topNLabel: document.getElementById('topNLabel'),
  includeNoGo: document.getElementById('includeNoGo'),
  rain24Penalty: document.getElementById('rain24Penalty'),
  useQpfScore: document.getElementById('useQpfScore'),

  rhGoMin: document.getElementById('rhGoMin'),
  rhGoMax: document.getElementById('rhGoMax'),
  rhNoGoLow: document.getElementById('rhNoGoLow'),
  rhNoGoHigh: document.getElementById('rhNoGoHigh'),
  windMax: document.getElementById('windMax'),
  gustMax: document.getElementById('gustMax'),
  mixMin: document.getElementById('mixMin'),
  qpfMax: document.getElementById('qpfMax'),
  rain24NoGo: document.getElementById('rain24NoGo'),
};

let STATE = {
  features: [],        // normalized features with centroid + tract etc.
  results: [],         // scored weather results
  cache: new Map(),    // url -> json
};

/* ---------------------------
   Config
   --------------------------- */

// Daytime window (local time at the point). Adjust if you want:
// e.g. 10‚Äì17, or sunrise/sunset later if you want to get fancy.
const DAY_START_HOUR = 9;    // 9 AM
const DAY_END_HOUR   = 18;   // 6 PM (exclusive)

/* ---------------------------
   Fetch helpers
   --------------------------- */

async function fetchJson(url){
  if (STATE.cache.has(url)) return STATE.cache.get(url);

  const res = await fetch(url, {
    headers: { "Accept": "application/geo+json,application/json" }
  });

  if(!res.ok){
    const text = await res.text().catch(()=>"(no body)");
    throw new Error(`HTTP ${res.status} for ${url}\n${text.slice(0,400)}`);
  }
  const data = await res.json();
  STATE.cache.set(url, data);
  return data;
}

/* ---------------------------
   Geometry / parsing helpers
   --------------------------- */

// Basic GeoJSON centroid (works for MultiPolygon/Polygon reasonably for burn units)
function centroidOfFeature(feat){
  const g = feat.geometry;
  if(!g) return null;

  function centroidOfRing(ring){
    let x=0,y=0,n=0;
    for(const p of ring){
      if(!Array.isArray(p) || p.length < 2) continue;
      x += p[0]; y += p[1]; n++;
    }
    if(n===0) return null;
    return [x/n, y/n];
  }

  function centroidOfPolygon(poly){
    if(!Array.isArray(poly) || poly.length===0) return null;
    return centroidOfRing(poly[0]);
  }

  if(g.type === "Polygon") return centroidOfPolygon(g.coordinates);

  if(g.type === "MultiPolygon"){
    let x=0,y=0,n=0;
    for(const poly of g.coordinates){
      const c = centroidOfPolygon(poly);
      if(!c) continue;
      x += c[0]; y += c[1]; n++;
    }
    if(n===0) return null;
    return [x/n,y/n];
  }
  return null;
}

// Case-insensitive property getter
function getPropCI(props, wanted){
  if(!props) return null;
  const keys = Object.keys(props);
  const w = wanted.toLowerCase();
  for(const k of keys){
    if(k.toLowerCase() === w) return props[k];
  }
  return null;
}

function getTract(props){
  const v = getPropCI(props, "tract");
  if(v === null || v === undefined) return null;
  const s = String(v).trim();
  return s.length ? s : null;
}

function getIdent(props){
  return getPropCI(props, "ident") ?? getPropCI(props, "unit") ?? getPropCI(props, "name") ?? getPropCI(props, "id") ?? "Unit";
}

function fmt(n, d=1){
  if(n===null || n===undefined || Number.isNaN(n)) return "‚Äî";
  return Number(n).toFixed(d);
}

function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }

// Parse validTime like: "2026-01-12T13:00:00+00:00/PT1H"
function parseValidTime(vt){
  const [start, dur] = vt.split("/");
  const startMs = Date.parse(start);
  const endMs = startMs + parseISODuration(dur);
  return {startMs, endMs};
}

// Small ISO-8601 duration parser for PT#H#M
function parseISODuration(d){
  let ms = 0;
  const mH = d.match(/(\d+)H/);
  const mM = d.match(/(\d+)M/);
  if(mH) ms += Number(mH[1]) * 3600e3;
  if(mM) ms += Number(mM[1]) * 60e3;
  return ms || 0;
}

/* ---------------------------
   Daytime / timezone helpers
   --------------------------- */

function localHour(ms, timeZone){
  try{
    const parts = new Intl.DateTimeFormat('en-US', { timeZone, hour:'numeric', hour12:false }).formatToParts(new Date(ms));
    const h = parts.find(p=>p.type==='hour')?.value;
    return h != null ? Number(h) : null;
  }catch{
    return null;
  }
}

function isDaytimeStart(ms, timeZone){
  const h = localHour(ms, timeZone);
  if(h == null) return false;
  return (h >= DAY_START_HOUR && h < DAY_END_HOUR);
}

/* ---------------------------
   Series slicing
   --------------------------- */

// Extract values overlapping next 24h window (no time-of-day filter)
function sliceNext24(values){
  const t0 = Date.now();
  const t1 = t0 + 24*3600e3;
  const out = [];
  for(const it of values || []){
    if(it == null) continue;
    const vt = it.validTime;
    const val = it.value;
    if(vt == null || val == null) continue;
    const {startMs, endMs} = parseValidTime(vt);
    if(endMs <= t0) continue;
    if(startMs >= t1) continue;
    out.push(Number(val));
  }
  return out;
}

// Extract values overlapping next 24h window AND starting during local daytime
function sliceNext24Daytime(values, timeZone){
  const t0 = Date.now();
  const t1 = t0 + 24*3600e3;
  const out = [];
  for(const it of values || []){
    if(it == null) continue;
    const vt = it.validTime;
    const val = it.value;
    if(vt == null || val == null) continue;

    const {startMs, endMs} = parseValidTime(vt);
    if(endMs <= t0) continue;
    if(startMs >= t1) continue;

    // Keep only periods whose START is within local daytime
    if(!isDaytimeStart(startMs, timeZone)) continue;

    out.push(Number(val));
  }
  return out;
}

/* ---------------------------
   Forecast summarization
   --------------------------- */

// Summaries for decision / scoring.
// RH is daytime-only. Everything else is full next-24 window.
function summarizeNext24(gridProps, timeZone){
  const rh = sliceNext24Daytime(gridProps?.relativeHumidity?.values, timeZone);
  const ws = sliceNext24(gridProps?.windSpeed?.values);
  const wg = sliceNext24(gridProps?.windGust?.values);
  const mh = sliceNext24(gridProps?.mixingHeight?.values);
  const qpf = sliceNext24(gridProps?.quantitativePrecipitation?.values);

  const out = {
    rhMin: rh.length ? Math.min(...rh) : null,
    rhMax: rh.length ? Math.max(...rh) : null,
    windMax: ws.length ? Math.max(...ws) : null,
    gustMax: wg.length ? Math.max(...wg) : null,
    mixMin: mh.length ? Math.min(...mh) : null,
    qpfSumMm: qpf.length ? qpf.reduce((a,b)=>a+b,0) : null
  };
  // NWS QPF is usually in mm
  out.qpfSumIn = out.qpfSumMm==null ? null : out.qpfSumMm / 25.4;
  return out;
}

/* ---------------------------
   Rain: last 1/3/6 + last 24 hours
   --------------------------- */

// Latest station precip (mm) last 1/3/6 hours + last 24 hours if present
async function fetchRainSignal(observationStationsUrl){
  try{
    const stations = await fetchJson(observationStationsUrl);
    const first = stations?.observationStations?.[0];
    if(!first) return {ok:false, note:"No station list", p1mm:null,p3mm:null,p6mm:null,p24mm:null, recencyHours:null};

    const latestUrl = `${first}/observations/latest`;
    const obs = await fetchJson(latestUrl);
    const p = obs?.properties || {};

    const p1  = (p.precipitationLastHour?.value ?? null);
    const p3  = (p.precipitationLast3Hours?.value ?? null);
    const p6  = (p.precipitationLast6Hours?.value ?? null);

    // Many stations provide this; some don‚Äôt.
    const p24 = (p.precipitationLast24Hours?.value ?? null);

    let recencyHours = null;
    if(p1 != null && p1 > 0) recencyHours = 1;
    else if(p3 != null && p3 > 0) recencyHours = 3;
    else if(p6 != null && p6 > 0) recencyHours = 6;

    return {
      ok:true,
      station:first,
      timestamp: p.timestamp || null,
      p1mm: p1, p3mm: p3, p6mm: p6,
      p24mm: p24,
      recencyHours
    };
  }catch(e){
    return {ok:false, note:String(e).slice(0,160), p1mm:null,p3mm:null,p6mm:null,p24mm:null, recencyHours:null};
  }
}

/* ---------------------------
   Thresholds / options
   --------------------------- */

function readThresholds(){
  return {
    rhGoMin: Number(UI.rhGoMin.value),
    rhGoMax: Number(UI.rhGoMax.value),
    rhNoGoLow: Number(UI.rhNoGoLow.value),
    rhNoGoHigh: Number(UI.rhNoGoHigh.value),
    windMax: Number(UI.windMax.value),
    gustMax: Number(UI.gustMax.value),
    mixMin: Number(UI.mixMin.value),
    qpfMax: Number(UI.qpfMax.value),
    rain24NoGo: Number(UI.rain24NoGo.value),
  };
}

function readOptions(){
  return {
    topN: Number(UI.topN.value),
    includeNoGo: UI.includeNoGo.checked,
    rain24Penalty: UI.rain24Penalty.checked,
    useQpfScore: UI.useQpfScore.checked,
  };
}

function setStatus(s){ UI.status.textContent = s; }

/* ---------------------------
   Decision classification
   --------------------------- */

function mmToIn(mm){
  if(mm == null) return null;
  return mm / 25.4;
}

function classify(summary, rain, thr){
  // Missing forecast essentials -> NO-GO
  const needed = ["rhMin","rhMax","windMax","gustMax","mixMin","qpfSumIn"];
  for(const k of needed){
    if(summary[k] == null) return {status:"NO-GO", reason:`Missing ${k} (daytime RH needs daytime samples)`};
  }

  // Daytime RH hard NO-GO
  if(summary.rhMin < thr.rhNoGoLow || summary.rhMax > thr.rhNoGoHigh) return {status:"NO-GO", reason:"DAYTIME RH out of bounds"};

  // Wind / mixing / QPF
  if(summary.windMax > thr.windMax) return {status:"NO-GO", reason:"Wind too high"};
  if(summary.gustMax > thr.gustMax) return {status:"NO-GO", reason:"Gusts too high"};
  if(summary.mixMin < thr.mixMin) return {status:"NO-GO", reason:"Mixing height too low"};
  if(summary.qpfSumIn > thr.qpfMax) return {status:"NO-GO", reason:"Forecast precip (QPF) too high"};

  // Last-24h rain hard NO-GO (if we have it)
  const rain24In = rain?.ok ? mmToIn(rain.p24mm) : null;
  if(rain24In != null && rain24In > thr.rain24NoGo){
    return {status:"NO-GO", reason:`Too wet: last 24h rain ${rain24In.toFixed(2)} in`};
  }

  // GO vs CAUTION
  const inGoRh = (summary.rhMin >= thr.rhGoMin && summary.rhMax <= thr.rhGoMax);
  return inGoRh ? {status:"GO", reason:"Within GO envelope"} : {status:"CAUTION", reason:"Inside hard limits, outside GO envelope"};
}

/* ---------------------------
   Scoring (0‚Äì100)
   Prioritises best weather + penalises rain (last 24h) + optional QPF.
   --------------------------- */

function score(summary, rain, thr, opts){
  const rhMid = (summary.rhMin + summary.rhMax) / 2;
  const wind = summary.windMax;
  const gust = summary.gustMax;
  const mix  = summary.mixMin;
  const qpf  = summary.qpfSumIn;

  // RH: peak at 45, fade out (DAYTIME)
  const rhScore = (()=>{
    const ideal = 45;
    const dist = Math.abs(rhMid - ideal);
    return clamp(40 * (1 - dist/15), 0, 40);
  })();

  // Wind: best 6‚Äì12, penalty outside
  const windScore = (()=>{
    const idealLo = 6, idealHi = 12;
    if(wind >= idealLo && wind <= idealHi) return 30;
    if(wind < idealLo) return clamp(30 * (wind/idealLo), 0, 30);
    return clamp(30 * (1 - (wind-idealHi)/(thr.windMax-idealHi)), 0, 30);
  })();

  // Gust: prefer <=18
  const gustScore = (()=>{
    const good = 18;
    if(gust <= good) return 10;
    return clamp(10 * (1 - (gust-good)/(thr.gustMax-good)), 0, 10);
  })();

  // Mixing height: prefer >=1700, but accept above min
  const mixScore = (()=>{
    const good = 1700;
    if(mix >= good) return 10;
    return clamp(10 * ((mix - thr.mixMin) / (good - thr.mixMin)), 0, 10);
  })();

  // QPF: less is better (if enabled)
  const qpfScore = (()=>{
    if(!opts.useQpfScore) return 0;
    return clamp(10 * (1 - (qpf / thr.qpfMax)), 0, 10);
  })();

  // Rain last 24h penalty (inches). Stronger penalty if >=0.10"
  const rain24Adj = (()=>{
    if(!opts.rain24Penalty) return 0;
    if(!rain || !rain.ok) return 0;
    const rain24In = mmToIn(rain.p24mm);
    if(rain24In == null) return 0;

    // 0.00" -> 0 penalty
    // 0.05" -> -2
    // 0.10" -> -5
    // 0.25" -> -10
    const r = clamp(rain24In, 0, 0.25);
    return - (r / 0.25) * 10;
  })();

  let total = rhScore + windScore + gustScore + mixScore + qpfScore + rain24Adj;

  // If CAUTION (outside GO RH band), small penalty
  const inGoRh = (summary.rhMin >= thr.rhGoMin && summary.rhMax <= thr.rhGoMax);
  if(!inGoRh) total -= 6;

  return clamp(total, 0, 100);
}

/* ---------------------------
   Rendering
   --------------------------- */

function escapeHtml(s){
  return String(s ?? "").replace(/[&<>"']/g, (c)=>({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
  }[c]));
}

function makeCard(r){
  const tagClass = r.decision.status === "GO" ? "ready" : (r.decision.status === "CAUTION" ? "caution" : "nogo");

  const rainLine = (() => {
    if(!r.rain) return "Rain: ‚Äî";
    if(!r.rain.ok) return `Rain: unknown (${r.rain.note || "station error"})`;

    const parts = [];
    if(r.rain.p1mm != null) parts.push(`1h: ${fmt(r.rain.p1mm,2)}mm`);
    if(r.rain.p3mm != null) parts.push(`3h: ${fmt(r.rain.p3mm,2)}mm`);
    if(r.rain.p6mm != null) parts.push(`6h: ${fmt(r.rain.p6mm,2)}mm`);
    const rec = r.rain.recencyHours ? `measurable ‚â§${r.rain.recencyHours}h` : "no measurable in last 6h";

    const p24in = mmToIn(r.rain.p24mm);
    const p24txt = (p24in == null) ? "24h: ‚Äî" : `24h: ${p24in.toFixed(2)} in`;

    return `Rain: ${rec}${parts.length ? ` (${parts.join(", ")})` : ""} ¬∑ ${p24txt}`;
  })();

  const scorePct = `${Math.round(r.score)}%`;

  return `
    <div class="card">
      <div class="cardHeader">
        <div>
          <p class="title">${escapeHtml(r.unitName)} <span class="mono" style="color:var(--muted);font-weight:700">¬∑ Tract ${escapeHtml(r.tract)}</span></p>
          <div class="warn">${escapeHtml(r.decision.reason)}</div>
        </div>
        <div class="tag ${tagClass}">${escapeHtml(r.decision.status)}</div>
      </div>

      <div class="sep"></div>

      <div class="kv">
        <div>Centroid <code class="mono">${fmt(r.lat,5)}, ${fmt(r.lon,5)}</code></div>
        <div>Timezone: <code class="mono">${escapeHtml(r.timeZone || "‚Äî")}</code></div>
        <div><b>DAYTIME</b> RH next 24h (range): <code>${fmt(r.summary.rhMin,0)}‚Äì${fmt(r.summary.rhMax,0)}%</code></div>
        <div>Wind max: <code>${fmt(r.summary.windMax,1)} mph</code> ¬∑ Gust max: <code>${fmt(r.summary.gustMax,1)} mph</code></div>
        <div>Mixing height min: <code>${fmt(r.summary.mixMin,0)} ft</code></div>
        <div>QPF next 24h sum: <code>${fmt(r.summary.qpfSumIn,2)} in</code></div>
        <div>${escapeHtml(rainLine)}</div>
      </div>

      <div class="sep"></div>

      <div class="scoreLine">
        <span>Burn Quality Score</span>
        <b style="color:var(--text)">${scorePct}</b>
      </div>
      <div class="bar"><div style="width:${r.score}%;"></div></div>

      <div class="warn" style="margin-top:10px">
        Source: <span class="mono">api.weather.gov</span> (grid + nearest station)
      </div>
    </div>
  `;
}

function render(){
  if(!STATE.results.length){
    UI.cards.innerHTML = `<div class="panel" style="grid-column:1/-1">
      No results to show. Try ‚ÄúInclude NO-GO‚Äù or adjust thresholds.
    </div>`;
    return;
  }
  UI.cards.innerHTML = STATE.results.map(makeCard).join("");
}

/* ---------------------------
   Core pipeline
   --------------------------- */

async function processGeoJSON(geo){
  if(!geo || geo.type !== "FeatureCollection" || !Array.isArray(geo.features)){
    throw new Error("Expected a GeoJSON FeatureCollection");
  }

  // Normalize features + skip missing Tract
  const feats = [];
  for(const f of geo.features){
    const tract = getTract(f.properties);
    if(!tract) continue; // rule: If none exist ‚Üí skip
    const c = centroidOfFeature(f);
    if(!c) continue;
    const [lon, lat] = c;
    if(!Number.isFinite(lat) || !Number.isFinite(lon)) continue;

    feats.push({
      tract,
      unitName: String(getIdent(f.properties)).trim(),
      lat, lon,
      raw: f
    });
  }

  STATE.features = feats;

  if(!feats.length){
    setStatus("No valid features found (need polygons + Tract field).");
    UI.cards.innerHTML = "";
    return;
  }

  setStatus(`Loaded ${feats.length} units with Tract. Fetching NWS‚Ä¶`);
  await fetchAndRank();
}

async function fetchAndRank(){
  const thr = readThresholds();
  const opts = readOptions();
  UI.topNLabel.textContent = String(opts.topN);

  const jobs = STATE.features.map(async (u) => {
    try{
      const pointsUrl = `https://api.weather.gov/points/${u.lat},${u.lon}`;
      const points = await fetchJson(pointsUrl);

      const gridUrl = points?.properties?.forecastGridData;
      const stationsUrl = points?.properties?.observationStations;
      const timeZone = points?.properties?.timeZone || null;

      if(!gridUrl || !stationsUrl) throw new Error("Missing grid or station URL");

      const grid = await fetchJson(gridUrl);

      // RH is daytime-only using point timezone. If timezone missing, it will likely drop RH samples.
      const summary = summarizeNext24(grid?.properties, timeZone || "America/New_York");

      const rain = await fetchRainSignal(stationsUrl);

      const decision = classify(summary, rain, thr);
      const scoreVal = score(summary, rain, thr, opts);

      return {
        ...u,
        timeZone,
        summary,
        rain,
        decision,
        score: scoreVal,
      };
    }catch(e){
      return {
        ...u,
        timeZone: null,
        summary: {rhMin:null,rhMax:null,windMax:null,gustMax:null,mixMin:null,qpfSumIn:null},
        rain: {ok:false, note:"fetch error", p1mm:null,p3mm:null,p6mm:null,p24mm:null},
        decision: {status:"NO-GO", reason:String(e).slice(0,120)},
        score: 0,
      };
    }
  });

  const all = await Promise.all(jobs);

  // Sort: GO over CAUTION over NO-GO, then score
  const rankStatus = (s)=> s==="GO" ? 2 : (s==="CAUTION" ? 1 : 0);

  let filtered = all.slice();
  if(!opts.includeNoGo){
    filtered = filtered.filter(x => x.decision.status !== "NO-GO");
  }

  filtered.sort((a,b)=>{
    const ds = rankStatus(b.decision.status) - rankStatus(a.decision.status);
    if(ds !== 0) return ds;
    return b.score - a.score;
  });

  const top = filtered.slice(0, opts.topN);

  STATE.results = top;
  setStatus(`Showing ${top.length} ranked candidates (from ${STATE.features.length} units).`);
  render();
}

/* ---------------------------
   UI wiring
   --------------------------- */

function clearAll(){
  STATE.features = [];
  STATE.results = [];
  STATE.cache.clear();
  UI.cards.innerHTML = "";
  setStatus("Waiting for GeoJSON‚Ä¶");
}

const fileInput = document.createElement('input');
fileInput.type = 'file';
fileInput.accept = '.json,.geojson,application/geo+json,application/json';
fileInput.style.display = 'none';
document.body.appendChild(fileInput);

UI.drop.addEventListener('click', ()=>fileInput.click());
UI.drop.addEventListener('keydown', (e)=>{ if(e.key==="Enter"||e.key===" "){ e.preventDefault(); fileInput.click(); } });

fileInput.addEventListener('change', async ()=>{
  const f = fileInput.files?.[0];
  if(!f) return;
  await loadFile(f);
  fileInput.value = "";
});

UI.drop.addEventListener('dragover', (e)=>{ e.preventDefault(); UI.drop.style.borderColor="rgba(251,113,133,.55)"; });
UI.drop.addEventListener('dragleave', ()=>{ UI.drop.style.borderColor="rgba(255,255,255,.18)"; });
UI.drop.addEventListener('drop', async (e)=>{
  e.preventDefault();
  UI.drop.style.borderColor="rgba(255,255,255,.18)";
  const f = e.dataTransfer?.files?.[0];
  if(!f) return;
  await loadFile(f);
});

async function loadFile(file){
  try{
    setStatus(`Reading ${file.name}‚Ä¶`);
    const text = await file.text();
    const geo = JSON.parse(text);
    await processGeoJSON(geo);
  }catch(e){
    setStatus("Error reading GeoJSON.");
    UI.cards.innerHTML = `<div class="panel" style="grid-column:1/-1">
      <b>Load failed:</b> <span class="mono">${escapeHtml(String(e))}</span>
    </div>`;
  }
}

UI.btnClear.addEventListener('click', clearAll);
UI.btnRecalc.addEventListener('click', async ()=>{
  if(!STATE.features.length){
    setStatus("Load GeoJSON first.");
    return;
  }
  setStatus("Recalculating‚Ä¶");
  await fetchAndRank();
});

UI.topN.addEventListener('input', ()=>UI.topNLabel.textContent = UI.topN.value);

UI.btnDemo.addEventListener('click', async ()=>{
  const demo = {
    type:"FeatureCollection",
    features:[
      {type:"Feature", properties:{Tract:"Citrus", Ident:"CI05"}, geometry:{type:"Polygon", coordinates:[[[-82.47,28.81],[-82.46,28.81],[-82.46,28.80],[-82.47,28.80],[-82.47,28.81]]]}},
      {type:"Feature", properties:{Tract:"Citrus", Ident:"CI06"}, geometry:{type:"Polygon", coordinates:[[[-82.44,28.82],[-82.43,28.82],[-82.43,28.81],[-82.44,28.81],[-82.44,28.82]]]}},
      {type:"Feature", properties:{Tract:"Richloam", Ident:"RI05"}, geometry:{type:"Polygon", coordinates:[[[-82.31,28.64],[-82.30,28.64],[-82.30,28.63],[-82.31,28.63],[-82.31,28.64]]]}},
      {type:"Feature", properties:{TRACT:"Richloam", Ident:"RI04"}, geometry:{type:"Polygon", coordinates:[[[-82.35,28.62],[-82.34,28.62],[-82.34,28.61],[-82.35,28.61],[-82.35,28.62]]]}},
      // This one will be skipped (no Tract)
      {type:"Feature", properties:{Ident:"SKIPME"}, geometry:{type:"Polygon", coordinates:[[[-82.5,28.7],[-82.49,28.7],[-82.49,28.69],[-82.5,28.69],[-82.5,28.7]]]}},
    ]
  };
  await processGeoJSON(demo);
});

// Initial
setStatus("Waiting for GeoJSON‚Ä¶");
</script>
</body>
</html>
