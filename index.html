<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>RX Boss — Florida Prescribed Burn GO / NO-GO</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#0f172a;
      --panel2:#0b1224;
      --text:#e5e7eb;
      --muted:#9ca3af;
      --line:rgba(255,255,255,.10);
      --blue:#60a5fa;
      --green:#34d399;
      --amber:#fbbf24;
      --red:#fb7185;
      --pill:#0b1020;
      --shadow: 0 20px 60px rgba(0,0,0,.40);
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      background: radial-gradient(1200px 600px at 30% 10%, rgba(96,165,250,.18), transparent 60%),
                  radial-gradient(900px 600px at 80% 20%, rgba(52,211,153,.10), transparent 55%),
                  linear-gradient(180deg, #070a14, var(--bg));
      color:var(--text);
      min-height:100vh;
    }
    .wrap{max-width:1200px;margin:0 auto;padding:28px 18px 40px}
    h1{margin:0 0 6px;font-size:44px;letter-spacing:-.02em;color:var(--blue)}
    .subtitle{margin:0 0 16px;color:var(--muted)}
    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius:18px;
      box-shadow:var(--shadow);
      padding:16px;
    }
    .topGrid{
      display:grid;
      grid-template-columns: 1.2fr .8fr;
      gap:14px;
    }
    @media (max-width: 980px){
      .topGrid{grid-template-columns:1fr}
    }
    .drop{
      border:2px dashed rgba(255,255,255,.18);
      border-radius:16px;
      padding:22px;
      text-align:center;
      background: rgba(0,0,0,.16);
      cursor:pointer;
      user-select:none;
      transition:.15s ease;
    }
    .drop:hover{border-color:rgba(96,165,250,.55)}
    .drop strong{font-size:18px}
    .small{color:var(--muted);font-size:13px;margin-top:8px}
    .row{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px}
    button{
      background:rgba(255,255,255,.06);
      border:1px solid var(--line);
      color:var(--text);
      padding:10px 12px;
      border-radius:12px;
      cursor:pointer;
      font-weight:600;
    }
    button:hover{border-color:rgba(96,165,250,.45)}
    .pill{
      display:inline-flex;gap:8px;align-items:center;
      padding:8px 10px;border-radius:999px;
      border:1px solid var(--line);
      background:rgba(0,0,0,.18);
      color:var(--muted);
      font-size:13px;
    }
    .pill b{color:var(--text);font-weight:700}
    .controls{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .ctrl{
      padding:12px;
      border:1px solid var(--line);
      border-radius:14px;
      background: rgba(0,0,0,.14);
    }
    .ctrl h3{margin:0 0 8px;font-size:14px;color:var(--text)}
    .ctrl label{display:flex;justify-content:space-between;gap:10px;align-items:center;margin:8px 0;color:var(--muted);font-size:13px}
    .ctrl input[type="number"]{
      width:110px;
      background:rgba(255,255,255,.06);
      border:1px solid var(--line);
      color:var(--text);
      border-radius:10px;
      padding:7px 8px;
    }
    .ctrl input[type="checkbox"]{transform:scale(1.15)}
    .cards{
      margin-top:16px;
      display:grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap:12px;
    }
    @media (max-width: 1100px){.cards{grid-template-columns:repeat(2,1fr)}}
    @media (max-width: 720px){.cards{grid-template-columns:1fr}}
    .card{
      border:1px solid var(--line);
      border-radius:16px;
      padding:12px 12px 10px;
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(0,0,0,.10));
      position:relative;
      overflow:hidden;
    }
    .cardHeader{display:flex;align-items:flex-start;justify-content:space-between;gap:10px}
    .title{
      font-size:16px;font-weight:800;letter-spacing:.01em;margin:0;
    }
    .tag{
      padding:4px 10px;border-radius:999px;border:1px solid var(--line);
      font-size:12px;font-weight:800;letter-spacing:.02em;
    }
    .tag.ready{color:var(--green);border-color:rgba(52,211,153,.35);background:rgba(52,211,153,.08)}
    .tag.caution{color:var(--amber);border-color:rgba(251,191,36,.35);background:rgba(251,191,36,.08)}
    .tag.nogo{color:var(--red);border-color:rgba(251,113,133,.35);background:rgba(251,113,133,.08)}
    .kv{margin-top:8px;color:var(--muted);font-size:13px;line-height:1.25}
    .kv code{color:var(--text);background:rgba(0,0,0,.20);padding:2px 6px;border-radius:8px;border:1px solid var(--line)}
    .kv .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}
    .sep{height:1px;background:var(--line);margin:10px 0}
    .scoreLine{display:flex;justify-content:space-between;align-items:center;color:var(--muted);font-size:12px}
    .bar{height:8px;background:rgba(255,255,255,.08);border:1px solid var(--line);border-radius:999px;overflow:hidden;margin-top:6px}
    .bar > div{height:100%;background:rgba(96,165,250,.75)}
    .warn{color:var(--muted);font-size:12px;margin-top:8px}
    .footerNote{margin-top:14px;color:var(--muted);font-size:12px}
    a{color:var(--blue)}
  </style>
</head>

<body>
  <div class="wrap">
    <h1>RX Boss</h1>
    <p class="subtitle">Florida Prescribed Burn GO / NO-GO Decision Tool — ranks the <b>best burn candidates</b> by weather + recent rainfall signal.</p>

    <div class="topGrid">
      <div class="panel">
        <div id="drop" class="drop" tabindex="0">
          <strong>Drop GeoJSON burn units here</strong> <span class="small">(or click to select)</span>
          <div class="small">Accepts <b>.geojson</b> or <b>.json</b> FeatureCollections. Needs polygons. Must include a <b>Tract</b> field (any case). If none exist → skipped.</div>
        </div>

        <div class="row">
          <button id="btnClear">Clear</button>
          <button id="btnDemo">Load demo data</button>
          <span class="pill"><b>Status:</b> <span id="status">Waiting for GeoJSON…</span></span>
          <span class="pill"><b>Output:</b> Top <span id="topNLabel">10</span> candidates</span>
        </div>

        <div class="footerNote">
          Uses NWS API: grid forecast (next 24h worst-case) + nearest station latest precip (last 1/3/6 hours when available).
        </div>
      </div>

      <div class="panel">
        <div class="controls">
          <div class="ctrl">
            <h3>GO / CAUTION / NO-GO thresholds</h3>

            <label>RH GO band (%) <span>
              <input id="rhGoMin" type="number" value="30" /> –
              <input id="rhGoMax" type="number" value="55" />
            </span></label>

            <label>RH hard NO-GO (<span class="mono">&lt;</span> / <span class="mono">&gt;</span>) <span>
              <input id="rhNoGoLow" type="number" value="25" /> /
              <input id="rhNoGoHigh" type="number" value="60" />
            </span></label>

            <label>Wind sustained max (mph) <input id="windMax" type="number" value="18" /></label>
            <label>Gust max (mph) <input id="gustMax" type="number" value="25" /></label>
            <label>Mixing height min (ft) <input id="mixMin" type="number" value="1200" /></label>
            <label>QPF next 24h max (in) <input id="qpfMax" type="number" value="0.10" step="0.01" /></label>
          </div>

          <div class="ctrl">
            <h3>Ranking & display</h3>
            <label>Show top N <input id="topN" type="number" value="10" min="1" max="50" /></label>
            <label>Include NO-GO in list <input id="includeNoGo" type="checkbox" /></label>
            <label>Penalize recent rain (last ≤6h) <input id="rainPenalty" type="checkbox" checked /></label>
            <label>Use QPF (forecast) in scoring <input id="useQpfScore" type="checkbox" checked /></label>
            <button id="btnRecalc">Recalculate</button>
          </div>
        </div>
      </div>
    </div>

    <div id="cards" class="cards"></div>
  </div>

<script>
/* ---------------------------
   RX Boss — GitHub Pages build
   --------------------------- */

const UI = {
  drop: document.getElementById('drop'),
  status: document.getElementById('status'),
  cards: document.getElementById('cards'),
  btnClear: document.getElementById('btnClear'),
  btnDemo: document.getElementById('btnDemo'),
  btnRecalc: document.getElementById('btnRecalc'),
  topN: document.getElementById('topN'),
  topNLabel: document.getElementById('topNLabel'),
  includeNoGo: document.getElementById('includeNoGo'),
  rainPenalty: document.getElementById('rainPenalty'),
  useQpfScore: document.getElementById('useQpfScore'),

  rhGoMin: document.getElementById('rhGoMin'),
  rhGoMax: document.getElementById('rhGoMax'),
  rhNoGoLow: document.getElementById('rhNoGoLow'),
  rhNoGoHigh: document.getElementById('rhNoGoHigh'),
  windMax: document.getElementById('windMax'),
  gustMax: document.getElementById('gustMax'),
  mixMin: document.getElementById('mixMin'),
  qpfMax: document.getElementById('qpfMax'),
};

let STATE = {
  features: [],        // normalized features with centroid + tract etc.
  results: [],         // scored weather results
  cache: new Map(),    // url -> json
};

// NWS requires a User-Agent contact string (best practice).
// GitHub Pages JS can't set the real UA, but we can send an Accept header.
async function fetchJson(url){
  if (STATE.cache.has(url)) return STATE.cache.get(url);

  const res = await fetch(url, {
    headers: {
      "Accept": "application/geo+json,application/json"
    }
  });

  if(!res.ok){
    const text = await res.text().catch(()=>"(no body)");
    throw new Error(`HTTP ${res.status} for ${url}\n${text.slice(0,400)}`);
  }
  const data = await res.json();
  STATE.cache.set(url, data);
  return data;
}

// Basic GeoJSON centroid (works for MultiPolygon/Polygon reasonably for burn units)
function centroidOfFeature(feat){
  const g = feat.geometry;
  if(!g) return null;

  function centroidOfRing(ring){
    // ring: [[lon,lat],...]
    let x=0,y=0,n=0;
    for(const p of ring){
      if(!Array.isArray(p) || p.length < 2) continue;
      x += p[0]; y += p[1]; n++;
    }
    if(n===0) return null;
    return [x/n, y/n];
  }

  function centroidOfPolygon(poly){
    // poly: [ring0, ring1...]
    if(!Array.isArray(poly) || poly.length===0) return null;
    return centroidOfRing(poly[0]); // outer ring
  }

  if(g.type === "Polygon"){
    return centroidOfPolygon(g.coordinates);
  }
  if(g.type === "MultiPolygon"){
    // average centroids of polygons
    let x=0,y=0,n=0;
    for(const poly of g.coordinates){
      const c = centroidOfPolygon(poly);
      if(!c) continue;
      x += c[0]; y += c[1]; n++;
    }
    if(n===0) return null;
    return [x/n,y/n];
  }
  return null;
}

// Case-insensitive property getter + common synonyms
function getPropCI(props, wanted){
  if(!props) return null;
  const keys = Object.keys(props);
  const w = wanted.toLowerCase();
  for(const k of keys){
    if(k.toLowerCase() === w) return props[k];
  }
  return null;
}

function getTract(props){
  const v = getPropCI(props, "tract") ?? getPropCI(props, "Tract") ?? getPropCI(props, "TRACT");
  if(v === null || v === undefined) return null;
  const s = String(v).trim();
  return s.length ? s : null;
}

function getIdent(props){
  return getPropCI(props, "ident") ?? getPropCI(props, "unit") ?? getPropCI(props, "name") ?? getPropCI(props, "id") ?? "Unit";
}

function fmt(n, d=1){
  if(n===null || n===undefined || Number.isNaN(n)) return "—";
  return Number(n).toFixed(d);
}

function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }

function nowISO(){ return new Date().toISOString(); }

// Parse validTime like: "2026-01-12T13:00:00+00:00/PT1H"
function parseValidTime(vt){
  const [start, dur] = vt.split("/");
  const startMs = Date.parse(start);
  const endMs = startMs + parseISODuration(dur);
  return {startMs, endMs};
}

// Very small ISO-8601 duration parser for PT#H#M
function parseISODuration(d){
  // examples: PT1H, PT3H, PT30M, PT1H30M
  let ms = 0;
  const mH = d.match(/(\d+)H/);
  const mM = d.match(/(\d+)M/);
  if(mH) ms += Number(mH[1]) * 3600e3;
  if(mM) ms += Number(mM[1]) * 60e3;
  return ms || 0;
}

// Extract values overlapping the next 24h window
function sliceNext24(values){
  const t0 = Date.now();
  const t1 = t0 + 24*3600e3;
  const out = [];
  for(const it of values || []){
    if(it == null) continue;
    const vt = it.validTime;
    const val = it.value;
    if(vt == null || val == null) continue;
    const {startMs, endMs} = parseValidTime(vt);
    // overlap?
    if(endMs <= t0) continue;
    if(startMs >= t1) continue;
    out.push(Number(val));
  }
  return out;
}

// Worst-case summaries for decision
function summarizeNext24(grid){
  // grid = forecastGridData.properties
  const rh = sliceNext24(grid?.relativeHumidity?.values);
  const ws = sliceNext24(grid?.windSpeed?.values);
  const wg = sliceNext24(grid?.windGust?.values);
  const mh = sliceNext24(grid?.mixingHeight?.values);
  const qpf = sliceNext24(grid?.quantitativePrecipitation?.values);

  const out = {
    rhMin: rh.length ? Math.min(...rh) : null,
    rhMax: rh.length ? Math.max(...rh) : null,
    windMax: ws.length ? Math.max(...ws) : null,
    gustMax: wg.length ? Math.max(...wg) : null,
    mixMin: mh.length ? Math.min(...mh) : null,
    qpfSumMm: qpf.length ? qpf.reduce((a,b)=>a+b,0) : null
  };
  // NWS QPF is usually in mm
  out.qpfSumIn = out.qpfSumMm==null ? null : out.qpfSumMm / 25.4;
  return out;
}

// Latest station precip (mm) last 1/3/6 hours if present
async function fetchLastRainSignal(observationStationsUrl){
  try{
    const stations = await fetchJson(observationStationsUrl);
    const first = stations?.observationStations?.[0];
    if(!first) return {ok:false, note:"No station list", p1:null,p3:null,p6:null};

    const latestUrl = `${first}/observations/latest`;
    const obs = await fetchJson(latestUrl);
    const p = obs?.properties || {};

    const p1 = (p.precipitationLastHour?.value ?? null);
    const p3 = (p.precipitationLast3Hours?.value ?? null);
    const p6 = (p.precipitationLast6Hours?.value ?? null);

    // Rain recency heuristic:
    // If precip in last hour >0 -> "≤1h"
    // else if last3Hours >0 -> "≤3h"
    // else if last6Hours >0 -> "≤6h"
    // else "no measurable in last 6h"
    let recencyHours = null;
    if(p1 != null && p1 > 0) recencyHours = 1;
    else if(p3 != null && p3 > 0) recencyHours = 3;
    else if(p6 != null && p6 > 0) recencyHours = 6;

    return {
      ok:true,
      station:first,
      timestamp: p.timestamp || null,
      p1mm: p1, p3mm: p3, p6mm: p6,
      recencyHours
    };
  }catch(e){
    return {ok:false, note:String(e).slice(0,160), p1mm:null,p3mm:null,p6mm:null, recencyHours:null};
  }
}

// Decision classification
function classify(summary, thr){
  // Missing is automatic NO-GO
  const needed = ["rhMin","rhMax","windMax","gustMax","mixMin","qpfSumIn"];
  for(const k of needed){
    if(summary[k] == null) return {status:"NO-GO", reason:`Missing ${k}`};
  }

  // Hard NO-GO
  if(summary.rhMin < thr.rhNoGoLow || summary.rhMax > thr.rhNoGoHigh) return {status:"NO-GO", reason:"RH out of bounds"};
  if(summary.windMax > thr.windMax) return {status:"NO-GO", reason:"Wind too high"};
  if(summary.gustMax > thr.gustMax) return {status:"NO-GO", reason:"Gusts too high"};
  if(summary.mixMin < thr.mixMin) return {status:"NO-GO", reason:"Mixing height too low"};
  if(summary.qpfSumIn > thr.qpfMax) return {status:"NO-GO", reason:"Forecast precip too high"};

  // GO vs CAUTION:
  const inGoRh = (summary.rhMin >= thr.rhGoMin && summary.rhMax <= thr.rhGoMax);
  return inGoRh ? {status:"GO", reason:"Within GO envelope"} : {status:"CAUTION", reason:"Inside hard limits, outside GO envelope"};
}

// Scoring (0–100). Prioritises best weather + penalises recent rain.
function score(summary, rain, thr, opts){
  // Base score on midpoints / extremes:
  const rhMid = (summary.rhMin + summary.rhMax) / 2;
  const wind = summary.windMax;
  const gust = summary.gustMax;
  const mix = summary.mixMin;
  const qpf = summary.qpfSumIn;

  // RH: peak at 45, fade out
  const rhScore = (()=>{
    const ideal = 45;
    const dist = Math.abs(rhMid - ideal);
    // 0 dist -> 40, dist 15 -> ~0
    return clamp(40 * (1 - dist/15), 0, 40);
  })();

  // Wind: best 6–12, penalty outside
  const windScore = (()=>{
    const idealLo = 6, idealHi = 12;
    if(wind >= idealLo && wind <= idealHi) return 30;
    if(wind < idealLo){
      // 0–6 -> scale down
      return clamp(30 * (wind/idealLo), 0, 30);
    }
    // 12–18 -> scale down
    return clamp(30 * (1 - (wind-idealHi)/(thr.windMax-idealHi)), 0, 30);
  })();

  // Gust spread / gusts: prefer ≤18
  const gustScore = (()=>{
    const good = 18;
    if(gust <= good) return 10;
    return clamp(10 * (1 - (gust-good)/(thr.gustMax-good)), 0, 10);
  })();

  // Mixing height: prefer ≥1700, but accept anything above min
  const mixScore = (()=>{
    const good = 1700;
    if(mix >= good) return 10;
    return clamp(10 * ((mix - thr.mixMin) / (good - thr.mixMin)), 0, 10);
  })();

  // QPF: less is better (if enabled)
  const qpfScore = (()=>{
    if(!opts.useQpfScore) return 0;
    // 0 -> 10, thr.qpfMax -> 0
    return clamp(10 * (1 - (qpf / thr.qpfMax)), 0, 10);
  })();

  // Recent rain penalty (if enabled)
  const rainAdj = (()=>{
    if(!opts.rainPenalty) return 0;
    // penalize if measurable rain in last 6h. Strongest penalty if ≤1h.
    if(!rain || rain.recencyHours == null) return 0;
    if(rain.recencyHours === 1) return -10;
    if(rain.recencyHours === 3) return -7;
    if(rain.recencyHours === 6) return -4;
    return 0;
  })();

  let total = rhScore + windScore + gustScore + mixScore + qpfScore + rainAdj;

  // If CAUTION (outside GO RH band but still within hard limits), small penalty
  const inGoRh = (summary.rhMin >= thr.rhGoMin && summary.rhMax <= thr.rhGoMax);
  if(!inGoRh) total -= 6;

  return clamp(total, 0, 100);
}

function readThresholds(){
  return {
    rhGoMin: Number(UI.rhGoMin.value),
    rhGoMax: Number(UI.rhGoMax.value),
    rhNoGoLow: Number(UI.rhNoGoLow.value),
    rhNoGoHigh: Number(UI.rhNoGoHigh.value),
    windMax: Number(UI.windMax.value),
    gustMax: Number(UI.gustMax.value),
    mixMin: Number(UI.mixMin.value),
    qpfMax: Number(UI.qpfMax.value),
  };
}

function readOptions(){
  return {
    topN: Number(UI.topN.value),
    includeNoGo: UI.includeNoGo.checked,
    rainPenalty: UI.rainPenalty.checked,
    useQpfScore: UI.useQpfScore.checked,
  };
}

function setStatus(s){ UI.status.textContent = s; }

function clearAll(){
  STATE.features = [];
  STATE.results = [];
  STATE.cache.clear();
  UI.cards.innerHTML = "";
  setStatus("Waiting for GeoJSON…");
}

function makeCard(r){
  const tagClass = r.decision.status === "GO" ? "ready" : (r.decision.status === "CAUTION" ? "caution" : "nogo");

  const rainLine = (() => {
    if(!r.rain) return "Last rain: —";
    if(!r.rain.ok) return `Last rain: unknown (${r.rain.note || "station error"})`;
    const mm = [];
    if(r.rain.p1mm != null) mm.push(`1h: ${fmt(r.rain.p1mm,2)}mm`);
    if(r.rain.p3mm != null) mm.push(`3h: ${fmt(r.rain.p3mm,2)}mm`);
    if(r.rain.p6mm != null) mm.push(`6h: ${fmt(r.rain.p6mm,2)}mm`);
    const rec = r.rain.recencyHours ? `measurable ≤${r.rain.recencyHours}h` : "no measurable in last 6h";
    return `Last rain: ${rec}${mm.length ? ` (${mm.join(", ")})` : ""}`;
  })();

  const scorePct = `${Math.round(r.score)}%`;

  return `
    <div class="card">
      <div class="cardHeader">
        <div>
          <p class="title">${escapeHtml(r.unitName)} <span class="mono" style="color:var(--muted);font-weight:700">· Tract ${escapeHtml(r.tract)}</span></p>
          <div class="warn">${escapeHtml(r.decision.reason)}</div>
        </div>
        <div class="tag ${tagClass}">${escapeHtml(r.decision.status)}</div>
      </div>

      <div class="sep"></div>

      <div class="kv">
        <div>Centroid <code class="mono">${fmt(r.lat,5)}, ${fmt(r.lon,5)}</code></div>
        <div>RH next 24h (worst): <code>${fmt(r.summary.rhMin,0)}–${fmt(r.summary.rhMax,0)}%</code></div>
        <div>Wind max: <code>${fmt(r.summary.windMax,1)} mph</code> · Gust max: <code>${fmt(r.summary.gustMax,1)} mph</code></div>
        <div>Mixing height min: <code>${fmt(r.summary.mixMin,0)} ft</code></div>
        <div>QPF next 24h sum: <code>${fmt(r.summary.qpfSumIn,2)} in</code></div>
        <div>${escapeHtml(rainLine)}</div>
      </div>

      <div class="sep"></div>

      <div class="scoreLine">
        <span>Burn Quality Score</span>
        <b style="color:var(--text)">${scorePct}</b>
      </div>
      <div class="bar"><div style="width:${r.score}%;"></div></div>

      <div class="warn" style="margin-top:10px">
        Source: <span class="mono">api.weather.gov</span> (grid + nearest station)
      </div>
    </div>
  `;
}

function escapeHtml(s){
  return String(s ?? "").replace(/[&<>"']/g, (c)=>({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#039;"
  }[c]));
}

async function processGeoJSON(geo){
  if(!geo || geo.type !== "FeatureCollection" || !Array.isArray(geo.features)){
    throw new Error("Expected a GeoJSON FeatureCollection");
  }

  // Normalize features + skip missing Tract
  const feats = [];
  for(const f of geo.features){
    const tract = getTract(f.properties);
    if(!tract) continue; // *** your rule: If none exist → skip ***
    const c = centroidOfFeature(f);
    if(!c) continue;
    const [lon, lat] = c;
    if(!Number.isFinite(lat) || !Number.isFinite(lon)) continue;

    feats.push({
      tract,
      unitName: String(getIdent(f.properties)).trim(),
      lat, lon,
      raw: f
    });
  }

  STATE.features = feats;

  if(!feats.length){
    setStatus("No valid features found (need polygons + Tract field).");
    UI.cards.innerHTML = "";
    return;
  }

  setStatus(`Loaded ${feats.length} units with Tract. Fetching NWS…`);

  await fetchAndRank();
}

async function fetchAndRank(){
  const thr = readThresholds();
  const opts = readOptions();
  UI.topNLabel.textContent = String(opts.topN);

  const jobs = STATE.features.map(async (u) => {
    try{
      // Points -> grid + stations
      const pointsUrl = `https://api.weather.gov/points/${u.lat},${u.lon}`;
      const points = await fetchJson(pointsUrl);
      const gridUrl = points?.properties?.forecastGridData;
      const stationsUrl = points?.properties?.observationStations;

      if(!gridUrl || !stationsUrl) throw new Error("Missing grid or station URL");

      const grid = await fetchJson(gridUrl);
      const summary = summarizeNext24(grid?.properties);

      const rain = await fetchLastRainSignal(stationsUrl);

      const decision = classify(summary, thr);
      const scoreVal = score(summary, rain, thr, opts);

      return {
        ...u,
        summary,
        rain,
        decision,
        score: scoreVal,
      };
    }catch(e){
      return {
        ...u,
        summary: {rhMin:null,rhMax:null,windMax:null,gustMax:null,mixMin:null,qpfSumIn:null},
        rain: {ok:false, note:"fetch error"},
        decision: {status:"NO-GO", reason:String(e).slice(0,120)},
        score: 0,
      };
    }
  });

  const all = await Promise.all(jobs);

  // Sort: best score first, GO over CAUTION over NO-GO as tie-breaker
  const rankStatus = (s)=> s==="GO" ? 2 : (s==="CAUTION" ? 1 : 0);

  let filtered = all.slice();
  if(!opts.includeNoGo){
    filtered = filtered.filter(x => x.decision.status !== "NO-GO");
  }

  filtered.sort((a,b)=>{
    const ds = rankStatus(b.decision.status) - rankStatus(a.decision.status);
    if(ds !== 0) return ds;
    return b.score - a.score;
  });

  const top = filtered.slice(0, opts.topN);

  STATE.results = top;

  setStatus(`Showing ${top.length} ranked candidates (from ${STATE.features.length} units).`);

  render();
}

function render(){
  if(!STATE.results.length){
    UI.cards.innerHTML = `<div class="panel" style="grid-column:1/-1">
      No results to show. Try “Include NO-GO” or adjust thresholds.
    </div>`;
    return;
  }
  UI.cards.innerHTML = STATE.results.map(makeCard).join("");
}

/* ---------------------------
   File input + drag/drop
   --------------------------- */

const fileInput = document.createElement('input');
fileInput.type = 'file';
fileInput.accept = '.json,.geojson,application/geo+json,application/json';
fileInput.style.display = 'none';
document.body.appendChild(fileInput);

UI.drop.addEventListener('click', ()=>fileInput.click());
UI.drop.addEventListener('keydown', (e)=>{ if(e.key==="Enter"||e.key===" "){ e.preventDefault(); fileInput.click(); } });

fileInput.addEventListener('change', async ()=>{
  const f = fileInput.files?.[0];
  if(!f) return;
  await loadFile(f);
  fileInput.value = "";
});

UI.drop.addEventListener('dragover', (e)=>{ e.preventDefault(); UI.drop.style.borderColor="rgba(96,165,250,.55)"; });
UI.drop.addEventListener('dragleave', ()=>{ UI.drop.style.borderColor="rgba(255,255,255,.18)"; });
UI.drop.addEventListener('drop', async (e)=>{
  e.preventDefault();
  UI.drop.style.borderColor="rgba(255,255,255,.18)";
  const f = e.dataTransfer?.files?.[0];
  if(!f) return;
  await loadFile(f);
});

async function loadFile(file){
  try{
    setStatus(`Reading ${file.name}…`);
    const text = await file.text();
    const geo = JSON.parse(text);
    await processGeoJSON(geo);
  }catch(e){
    setStatus("Error reading GeoJSON.");
    UI.cards.innerHTML = `<div class="panel" style="grid-column:1/-1">
      <b>Load failed:</b> <span class="mono">${escapeHtml(String(e))}</span>
    </div>`;
  }
}

UI.btnClear.addEventListener('click', clearAll);
UI.btnRecalc.addEventListener('click', async ()=>{
  if(!STATE.features.length){
    setStatus("Load GeoJSON first.");
    return;
  }
  setStatus("Recalculating…");
  await fetchAndRank();
});

UI.topN.addEventListener('input', ()=>UI.topNLabel.textContent = UI.topN.value);

UI.btnDemo.addEventListener('click', async ()=>{
  // Tiny demo FeatureCollection with fake polygons + Tract fields
  const demo = {
    type:"FeatureCollection",
    features:[
      {type:"Feature", properties:{Tract:"Citrus", Ident:"CI05"}, geometry:{type:"Polygon", coordinates:[[[-82.47,28.81],[-82.46,28.81],[-82.46,28.80],[-82.47,28.80],[-82.47,28.81]]]}},
      {type:"Feature", properties:{Tract:"Citrus", Ident:"CI06"}, geometry:{type:"Polygon", coordinates:[[[-82.44,28.82],[-82.43,28.82],[-82.43,28.81],[-82.44,28.81],[-82.44,28.82]]]}},
      {type:"Feature", properties:{Tract:"Richloam", Ident:"RI05"}, geometry:{type:"Polygon", coordinates:[[[-82.31,28.64],[-82.30,28.64],[-82.30,28.63],[-82.31,28.63],[-82.31,28.64]]]}},
      {type:"Feature", properties:{TRACT:"Richloam", Ident:"RI04"}, geometry:{type:"Polygon", coordinates:[[[-82.35,28.62],[-82.34,28.62],[-82.34,28.61],[-82.35,28.61],[-82.35,28.62]]]}},
      // This one will be skipped (no Tract)
      {type:"Feature", properties:{Ident:"SKIPME"}, geometry:{type:"Polygon", coordinates:[[[-82.5,28.7],[-82.49,28.7],[-82.49,28.69],[-82.5,28.69],[-82.5,28.7]]]}},
    ]
  };
  await processGeoJSON(demo);
});

// Initial
setStatus("Waiting for GeoJSON…");
</script>
</body>
</html>
