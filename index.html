<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>RX Boss — Florida Prescribed Burn GO / NO-GO</title>
  <style>
    :root{
      --bg0:#120607;
      --bg1:#1b0a0b;
      --card:#0f1216cc;
      --card2:#0f1216f0;
      --stroke:#ffffff18;
      --text:#e9eef6;
      --muted:#a9b4c3;
      --good:#2dd4bf;
      --warn:#f59e0b;
      --bad:#fb7185;
      --accent:#ff3b30;
      --accent2:#ff6a3d;
      --shadow: 0 18px 60px rgba(0,0,0,.45);
      --radius: 18px;
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    body{
      margin:0;
      font-family:var(--sans);
      color:var(--text);
      background:
        radial-gradient(1200px 700px at 25% 10%, rgba(255,59,48,.18), transparent 60%),
        radial-gradient(900px 600px at 80% 30%, rgba(255,106,61,.12), transparent 60%),
        radial-gradient(1200px 900px at 50% 110%, rgba(255,59,48,.10), transparent 60%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      min-height:100vh;
    }
    .wrap{ max-width:1180px; margin:0 auto; padding:28px 18px 48px; }
    header{ display:flex; gap:16px; align-items:flex-start; justify-content:space-between; flex-wrap:wrap; }
    h1{ margin:0; font-size:40px; letter-spacing:-.02em; }
    .sub{ margin-top:6px; color:var(--muted); max-width:760px; line-height:1.35; }
    .pillbar{ display:flex; gap:10px; flex-wrap:wrap; margin-top:14px;}
    .pill{
      padding:8px 10px;
      background:#ffffff08;
      border:1px solid var(--stroke);
      border-radius:999px;
      color:var(--muted);
      font-size:13px;
    }

    .panel{
      margin-top:18px;
      background:linear-gradient(180deg, #ffffff10, #ffffff06);
      border:1px solid var(--stroke);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:16px;
      backdrop-filter: blur(10px);
    }

    .drop{
      border:2px dashed #ffffff25;
      border-radius:16px;
      padding:18px;
      min-height:120px;
      display:flex;
      align-items:center;
      justify-content:center;
      text-align:center;
      cursor:pointer;
      background: rgba(10,12,16,.35);
      transition: .15s ease;
      user-select:none;
    }
    .drop.drag{ border-color: rgba(255,59,48,.65); background: rgba(255,59,48,.08); }
    .drop b{ color:#fff; }
    .drop small{ display:block; color:var(--muted); margin-top:6px; }
    input[type="file"]{ display:none; }

    .row{ display:flex; gap:14px; flex-wrap:wrap; align-items:flex-end; }
    .row > *{ flex:1; min-width:220px; }

    .controls{
      display:grid;
      grid-template-columns: repeat(3, minmax(0,1fr));
      gap:12px;
      margin-top:12px;
    }
    @media (max-width: 980px){
      .controls{ grid-template-columns: 1fr; }
    }
    .ctl{
      background: rgba(0,0,0,.22);
      border:1px solid var(--stroke);
      border-radius:16px;
      padding:12px;
    }
    .ctl label{ display:flex; justify-content:space-between; gap:10px; font-size:13px; color:var(--muted); }
    .ctl label span.val{ color:#fff; font-family:var(--mono); }
    .ctl input[type="range"]{ width:100%; margin-top:8px; }
    .ctl input[type="number"]{
      width:120px; padding:8px 10px; border-radius:12px;
      border:1px solid var(--stroke); background:#0b0d11; color:#fff;
      font-family:var(--mono);
    }

    .status{
      margin-top:12px;
      display:flex;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
      color:var(--muted);
      font-size:13px;
    }
    .status b{ color:#fff; }
    .btns{ display:flex; gap:10px; flex-wrap:wrap; }
    button{
      border:1px solid var(--stroke);
      background:#ffffff08;
      color:#fff;
      padding:10px 12px;
      border-radius:14px;
      cursor:pointer;
      transition: .12s ease;
    }
    button:hover{ transform: translateY(-1px); background:#ffffff0e; }
    button.primary{
      border-color: rgba(255,59,48,.35);
      background: linear-gradient(180deg, rgba(255,59,48,.25), rgba(255,59,48,.10));
    }

    .grid{
      margin-top:16px;
      display:grid;
      grid-template-columns: repeat(3, minmax(0,1fr));
      gap:14px;
    }
    @media (max-width: 980px){
      .grid{ grid-template-columns: 1fr; }
    }
    .card{
      background: linear-gradient(180deg, rgba(0,0,0,.26), rgba(0,0,0,.18));
      border:1px solid var(--stroke);
      border-radius:18px;
      padding:14px;
      box-shadow: 0 20px 50px rgba(0,0,0,.35);
      position:relative;
      overflow:hidden;
    }
    .card::before{
      content:"";
      position:absolute; inset:-2px;
      background: radial-gradient(600px 220px at 20% 0%, rgba(255,59,48,.10), transparent 60%);
      pointer-events:none;
    }
    .card h3{ margin:0; font-size:16px; letter-spacing:-.01em; display:flex; justify-content:space-between; gap:10px; }
    .tag{
      font-size:12px;
      padding:4px 9px;
      border-radius:999px;
      border:1px solid var(--stroke);
      background:#ffffff08;
    }
    .tag.go{ border-color: rgba(45,212,191,.45); color: var(--good); }
    .tag.caution{ border-color: rgba(245,158,11,.45); color: var(--warn); }
    .tag.nogo{ border-color: rgba(251,113,133,.45); color: var(--bad); }

    .kv{ margin-top:10px; font-family:var(--mono); font-size:12.5px; color:#dbe5f3; }
    .kv div{ display:flex; justify-content:space-between; gap:10px; padding:3px 0; border-bottom:1px dashed #ffffff12; }
    .kv div:last-child{ border-bottom:none; }
    .kv span.k{ color:var(--muted); font-family:var(--sans); font-size:12.5px; }
    .small{ margin-top:10px; color:var(--muted); font-size:12px; }
    .bar{
      margin-top:10px; height:8px; border-radius:999px;
      background:#ffffff10; border:1px solid #ffffff12; overflow:hidden;
    }
    .bar > i{
      display:block; height:100%;
      background: linear-gradient(90deg, rgba(45,212,191,.95), rgba(245,158,11,.9), rgba(251,113,133,.92));
      width:50%;
    }

    .error{
      margin-top:12px;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(251,113,133,.35);
      background: rgba(251,113,133,.08);
      color:#ffd7de;
      font-size:13px;
      white-space:pre-wrap;
    }
    .hint{ font-size:12px; color:var(--muted); margin-top:10px; line-height:1.35; }
    a{ color:#ffb4a9; }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <div>
        <h1>RX Boss</h1>
        <div class="sub">
          Upload your own burn-unit GeoJSON. The app fetches NWS grid weather for each unit’s centroid and ranks the best candidates.
          **Daytime** metrics are used (Florida reality: RH spikes overnight).
        </div>
        <div class="pillbar">
          <div class="pill">Input: FeatureCollection (.geojson/.json)</div>
          <div class="pill">Weather: api.weather.gov (points → grid)</div>
          <div class="pill">Daytime window adjustable</div>
          <div class="pill">Shows Top 10 best tracts</div>
        </div>
      </div>
      <div class="btns">
        <button id="btnClear">Clear</button>
        <button id="btnRun" class="primary" disabled>Fetch weather + rank</button>
      </div>
    </header>

    <div class="panel">
      <div class="row">
        <div>
          <div id="drop" class="drop" tabindex="0" role="button" aria-label="Upload GeoJSON">
            <div>
              <b>Drop GeoJSON burn units here</b> (or click to select)
              <small>Must be a FeatureCollection with Polygon/MultiPolygon features. If tract/name missing → skipped.</small>
            </div>
          </div>
          <input id="file" type="file" accept=".geojson,.json,application/geo+json,application/json" />
          <div class="hint">
            Tip: export in <b>WGS84 / EPSG:4326</b>. If your coords aren’t lon/lat, the app will likely reject/score NO-GO.
          </div>
        </div>

        <div class="ctl">
          <label>Daytime start (local) <span class="val" id="vDayStart">9</span></label>
          <input id="dayStart" type="range" min="0" max="23" step="1" value="9">
          <label style="margin-top:10px;">Daytime end (local) <span class="val" id="vDayEnd">18</span></label>
          <input id="dayEnd" type="range" min="0" max="23" step="1" value="18">
          <div class="hint">These hours are evaluated in each unit’s local timezone (from NWS point metadata).</div>
        </div>

        <div class="ctl">
          <label>Max wind (mph) for GO <span class="val" id="vWindGo">15</span></label>
          <input id="windGo" type="range" min="5" max="30" step="1" value="15">
          <label style="margin-top:10px;">Max gust (mph) for GO <span class="val" id="vGustGo">20</span></label>
          <input id="gustGo" type="range" min="10" max="40" step="1" value="20">
          <div class="hint">Scoring uses these + RH + mixing height + rain/QPF.</div>
        </div>
      </div>

      <div class="controls">
        <div class="ctl">
          <label>Daytime RH GO min (%) <span class="val" id="vRhMin">30</span></label>
          <input id="rhMin" type="range" min="10" max="60" step="1" value="30">
          <label style="margin-top:10px;">Daytime RH GO max (%) <span class="val" id="vRhMax">55</span></label>
          <input id="rhMax" type="range" min="30" max="90" step="1" value="55">
        </div>

        <div class="ctl">
          <label>Daytime mixing height min GO (ft) <span class="val" id="vMixGo">1700</span></label>
          <input id="mixGo" type="range" min="200" max="6000" step="50" value="1700">
          <label style="margin-top:10px;">QPF next 24h max (in) <span class="val" id="vQpfMax">0.10</span></label>
          <input id="qpfMax" type="range" min="0" max="1.00" step="0.01" value="0.10">
        </div>

        <div class="ctl">
          <label>Show top N <span class="val" id="vTopN">10</span></label>
          <input id="topN" type="range" min="3" max="25" step="1" value="10">
          <label style="margin-top:10px;">Parallel fetches <span class="val" id="vPar">5</span></label>
          <input id="par" type="range" min="1" max="10" step="1" value="5">
          <div class="hint">Higher parallel = faster but can hit rate limits. 5 is safe.</div>
        </div>
      </div>

      <div class="status">
        <div id="status">Status: <b>Waiting for upload</b></div>
        <div id="meta"></div>
      </div>

      <div id="err" class="error" style="display:none;"></div>
    </div>

    <div class="panel" style="margin-top:14px;">
      <div style="display:flex;justify-content:space-between;gap:10px;flex-wrap:wrap;align-items:baseline;">
        <div style="color:var(--muted);font-size:13px;">
          Results are ranked by a conservative “Burn Quality Score” using <b>daytime RH</b>, <b>daytime min mixing height</b>, wind/gust, QPF and recent rain.
          Missing critical fields → NO-GO.
        </div>
        <div style="font-family:var(--mono);color:var(--muted);font-size:12px;" id="sourceNote"></div>
      </div>
      <div id="grid" class="grid"></div>
    </div>
  </div>

<script>
/* =========================
   RX Boss — single-file app
   ========================= */

const $ = (id) => document.getElementById(id);

const state = {
  features: [],
  fileName: null,
  lastResults: [],
};

function setStatus(html){ $("status").innerHTML = "Status: " + html; }
function setError(msg){
  const el = $("err");
  if(!msg){ el.style.display="none"; el.textContent=""; return; }
  el.style.display="block";
  el.textContent = msg;
}
function clamp(n,min,max){ return Math.max(min, Math.min(max, n)); }

function milesPerHourFromKnots(kts){ return kts * 1.15077945; }
function metersToFeet(m){ return m * 3.280839895; }
function mmToIn(mm){ return mm / 25.4; }

function updateUIValues(){
  $("vDayStart").textContent = $("dayStart").value;
  $("vDayEnd").textContent = $("dayEnd").value;
  $("vWindGo").textContent = $("windGo").value;
  $("vGustGo").textContent = $("gustGo").value;
  $("vRhMin").textContent = $("rhMin").value;
  $("vRhMax").textContent = $("rhMax").value;
  $("vMixGo").textContent = $("mixGo").value;
  $("vQpfMax").textContent = (+$("qpfMax").value).toFixed(2);
  $("vTopN").textContent = $("topN").value;
  $("vPar").textContent = $("par").value;

  // keep daytime end > start (at least 1 hr)
  const s = +$("dayStart").value;
  let e = +$("dayEnd").value;
  if(e === s) {
    e = (s+1) % 24;
    $("dayEnd").value = e;
    $("vDayEnd").textContent = e;
  }
}
["dayStart","dayEnd","windGo","gustGo","rhMin","rhMax","mixGo","qpfMax","topN","par"]
  .forEach(id => $(id).addEventListener("input", updateUIValues));
updateUIValues();

/* -------------------------
   GeoJSON parsing helpers
------------------------- */

function isFeatureCollection(obj){
  return obj && obj.type === "FeatureCollection" && Array.isArray(obj.features);
}

function getBestNameProps(props){
  if(!props) return { id:null, tract:null, label:null };
  const candidatesId = ["Ident","IDENT","Id","ID","Unit","UNIT","Name","NAME","BurnUnit","burnunit","UNIT_ID","unit_id"];
  const candidatesTract = ["Tract","TRACT","TractName","tract_name","Tract_Name","TR_NAME","TRCT","TR"];
  const pick = (arr)=> arr.map(k=>props[k]).find(v=>v!==undefined && v!==null && String(v).trim()!=="");
  const id = pick(candidatesId);
  const tract = pick(candidatesTract);
  const label = (id && tract) ? `${id} · Tract ${tract}` :
                (id) ? `${id}` :
                (tract) ? `Tract ${tract}` : null;
  return { id, tract, label };
}

function isLonLat(coord){
  const [x,y] = coord;
  return Number.isFinite(x) && Number.isFinite(y) && Math.abs(x) <= 180 && Math.abs(y) <= 90;
}

// Robust-ish centroid for Polygon/MultiPolygon: average of all vertices (good enough for burn units)
function centroidFromGeometry(geom){
  if(!geom) return null;
  const type = geom.type;
  const coords = geom.coordinates;
  let points = [];

  function pushRing(ring){
    for(const pt of ring){
      if(Array.isArray(pt) && pt.length>=2) points.push([+pt[0], +pt[1]]);
    }
  }

  if(type==="Polygon"){
    for(const ring of coords) pushRing(ring);
  } else if(type==="MultiPolygon"){
    for(const poly of coords){
      for(const ring of poly) pushRing(ring);
    }
  } else if(type==="Point"){
    points = [[+coords[0], +coords[1]]];
  } else {
    return null;
  }

  if(points.length < 1) return null;

  // validate lon/lat-ish; if lots are out of bounds, likely wrong CRS
  const validCount = points.filter(isLonLat).length;
  if(validCount / points.length < 0.9) return { badCRS:true };

  let sx=0, sy=0, n=0;
  for(const [x,y] of points){
    sx += x; sy += y; n++;
  }
  return { lon: sx/n, lat: sy/n, badCRS:false };
}

/* -------------------------
   NWS API helpers
------------------------- */

async function fetchJson(url){
  const res = await fetch(url, { headers: { "Accept":"application/geo+json,application/json" } });
  if(!res.ok){
    const txt = await res.text().catch(()=> "");
    throw new Error(`${res.status} ${res.statusText} for ${url}\n${txt.slice(0,250)}`);
  }
  return res.json();
}

// Convert NWS "validTime" like "2026-01-12T20:00:00+00:00/PT1H" into {start:Date, end:Date}
function parseValidTime(validTime){
  // split at "/P"
  const [startStr, durStr] = validTime.split("/");
  const start = new Date(startStr);
  // duration is ISO 8601 like "PT1H" "PT3H"
  // handle H + M only (NWS grid uses hours)
  let hours = 0, mins = 0;
  const h = durStr.match(/(\d+)H/);
  const m = durStr.match(/(\d+)M/);
  if(h) hours = +h[1];
  if(m) mins = +m[1];
  const end = new Date(start.getTime() + (hours*60+mins)*60000);
  return { start, end };
}

function hourInTimeZone(date, timeZone){
  // returns hour 0-23 in target tz
  const parts = new Intl.DateTimeFormat("en-US", { timeZone, hour:"numeric", hour12:false }).formatToParts(date);
  const h = parts.find(p=>p.type==="hour")?.value;
  return h===undefined ? null : +h;
}

function formatLocal(date, timeZone){
  return new Intl.DateTimeFormat("en-US", {
    timeZone,
    year:"numeric", month:"numeric", day:"numeric",
    hour:"numeric", minute:"2-digit"
  }).format(date);
}

// Extract a time series from NWS grid property {uom, values:[{validTime,value}...]}
function seriesFromGrid(prop){
  if(!prop || !Array.isArray(prop.values)) return [];
  const out = [];
  for(const v of prop.values){
    if(v.value === null || v.value === undefined) continue;
    const { start, end } = parseValidTime(v.validTime);
    out.push({ start, end, value: v.value });
  }
  return out;
}

// Consider all slices that overlap the next 24h from now
function filterNext24h(series){
  const now = new Date();
  const until = new Date(now.getTime() + 24*3600*1000);
  return series.filter(p => p.start < until && p.end > now);
}

// Keep only those series entries whose START hour (local tz) is within daytime window
function filterDaytime(series, timeZone, dayStart, dayEnd){
  const s = +dayStart, e = +dayEnd;
  return series.filter(p=>{
    const hr = hourInTimeZone(p.start, timeZone);
    if(hr===null) return false;
    // daytime window that doesn't wrap (we enforce end != start)
    if(s < e) return hr >= s && hr < e;
    // wrap-around (rare; allow)
    return (hr >= s) || (hr < e);
  });
}

function minMax(series){
  if(series.length===0) return null;
  let min = +Infinity, max = -Infinity;
  for(const p of series){
    const v = +p.value;
    if(!Number.isFinite(v)) continue;
    if(v < min) min = v;
    if(v > max) max = v;
  }
  if(min===+Infinity) return null;
  return { min, max };
}

function sum(series){
  let s = 0, any=false;
  for(const p of series){
    const v = +p.value;
    if(Number.isFinite(v)){ s += v; any=true; }
  }
  return any ? s : null;
}

/* -------------------------
   "Last rain" best effort
   - NWS grid has QPF; for "last rain" we try:
     1) use grid's "quantitativePrecipitation" (mm) as hourly-ish increments
     2) find most recent time with value > 0 in past 24h
   If absent, return null.
------------------------- */
function lastRainFromQpfSeries(qpfSeries, timeZone){
  // Look back 24h from now in series; find last slice with >0
  const now = new Date();
  const since = new Date(now.getTime() - 24*3600*1000);
  const past = qpfSeries.filter(p => p.end > since && p.start < now);
  // sort newest first
  past.sort((a,b)=> b.start - a.start);
  for(const p of past){
    const v = +p.value;
    if(Number.isFinite(v) && v > 0.1){ // mm threshold
      return { when: p.start, amountMm: v };
    }
  }
  return null;
}

/* -------------------------
   Scoring & decision
------------------------- */
function scoreUnit(metrics, thresholds){
  // Conservative scoring: 100 is best. Penalties for out-of-range.
  // Missing key metrics -> very low score.
  const need = ["rhDayMin","rhDayMax","windMaxMph","gustMaxMph","mixDayMinFt","qpf24In"];
  for(const k of need){
    if(metrics[k] === null || metrics[k] === undefined) return { score: 0, reason:`Missing ${k}` };
  }

  let score = 100;
  const reasons = [];

  // RH daytime: use range (min/max) compared to target window
  if(metrics.rhDayMin < thresholds.rhMin){
    const d = thresholds.rhMin - metrics.rhDayMin;
    score -= d * 1.2;
    reasons.push("Daytime RH too low");
  }
  if(metrics.rhDayMax > thresholds.rhMax){
    const d = metrics.rhDayMax - thresholds.rhMax;
    score -= d * 1.2;
    reasons.push("Daytime RH too high");
  }

  // Wind / gust
  if(metrics.windMaxMph > thresholds.windGo){
    const d = metrics.windMaxMph - thresholds.windGo;
    score -= d * 2.0;
    reasons.push("Wind above GO");
  }
  if(metrics.gustMaxMph > thresholds.gustGo){
    const d = metrics.gustMaxMph - thresholds.gustGo;
    score -= d * 1.6;
    reasons.push("Gust above GO");
  }

  // Mixing height daytime min
  if(metrics.mixDayMinFt < thresholds.mixGo){
    const d = thresholds.mixGo - metrics.mixDayMinFt;
    score -= (d/100) * 2.0;
    reasons.push("Mixing height too low");
  }

  // QPF next 24
  if(metrics.qpf24In > thresholds.qpfMax){
    const d = metrics.qpf24In - thresholds.qpfMax;
    score -= d * 40; // inches are big
    reasons.push("Too wet (QPF)");
  }

  score = clamp(score, 0, 100);

  // Label GO/CAUTION/NO-GO
  let label = "GO";
  if(score < 70) label = "CAUTION";
  if(score < 50) label = "NO-GO";

  // Hard NO-GO rules (very conservative):
  const hardNoGo =
    (metrics.rhDayMin < thresholds.rhMin - 10) ||
    (metrics.rhDayMax > thresholds.rhMax + 10) ||
    (metrics.windMaxMph > thresholds.windGo + 6) ||
    (metrics.gustMaxMph > thresholds.gustGo + 8) ||
    (metrics.mixDayMinFt < Math.max(200, thresholds.mixGo - 700)) ||
    (metrics.qpf24In > thresholds.qpfMax + 0.25);

  if(hardNoGo) label = "NO-GO";

  return { score, label, reason: reasons[0] || "Within thresholds" };
}

function tagClass(label){
  if(label==="GO") return "go";
  if(label==="CAUTION") return "caution";
  return "nogo";
}

/* -------------------------
   Rendering
------------------------- */
function renderCards(results, thresholds){
  const grid = $("grid");
  grid.innerHTML = "";
  if(results.length===0){
    grid.innerHTML = `<div class="hint">No results yet. Upload GeoJSON then click <b>Fetch weather + rank</b>.</div>`;
    return;
  }

  $("sourceNote").textContent = `Daytime hours: ${thresholds.dayStart}–${thresholds.dayEnd} local • Ranked by Burn Quality Score`;

  for(const r of results){
    const m = r.metrics;
    const pct = Math.round(r.score);
    const barW = `${pct}%`;

    const lastRain = m.lastRainWhen ? `${formatLocal(m.lastRainWhen, m.timeZone)}`
      : "unknown";

    const lastRainNote = m.lastRainWhen
      ? `last rain: ${lastRain} (${m.lastRainAmtIn.toFixed(2)} in)`
      : (m.lastRainReason || "last rain: unknown");

    const el = document.createElement("div");
    el.className = "card";
    el.innerHTML = `
      <h3>
        <span>${escapeHtml(r.label)}</span>
        <span class="tag ${tagClass(r.decision)}">${r.decision}</span>
      </h3>
      <div class="small">${escapeHtml(r.reason)}</div>

      <div class="kv">
        <div><span class="k">Centroid</span><span>${m.lat.toFixed(5)}, ${m.lon.toFixed(5)}</span></div>
        <div><span class="k">Timezone</span><span>${escapeHtml(m.timeZone)}</span></div>
        <div><span class="k">DAYTIME RH (${thresholds.dayStart}–${thresholds.dayEnd})</span><span>${m.rhDayMin.toFixed(0)}–${m.rhDayMax.toFixed(0)}%</span></div>
        <div><span class="k">Wind max (next 24h)</span><span>${m.windMaxMph.toFixed(1)} mph</span></div>
        <div><span class="k">Gust max (next 24h)</span><span>${m.gustMaxMph.toFixed(1)} mph</span></div>
        <div><span class="k">DAYTIME min mixing height</span><span>${Math.round(m.mixDayMinFt)} ft</span></div>
        <div><span class="k">QPF next 24h sum</span><span>${m.qpf24In.toFixed(2)} in</span></div>
        <div><span class="k">${escapeHtml(lastRainNote.split(":")[0])}</span><span>${escapeHtml(lastRainNote.split(":").slice(1).join(":").trim())}</span></div>
      </div>

      <div class="small">Burn Quality Score <b style="float:right;color:#fff;">${pct}%</b></div>
      <div class="bar"><i style="width:${barW}"></i></div>

      <div class="small">Source: api.weather.gov (points → grid forecastGridData)</div>
    `;
    grid.appendChild(el);
  }
}

function escapeHtml(str){
  return String(str).replace(/[&<>"']/g, (m)=>({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
  }[m]));
}

/* -------------------------
   Load + validate GeoJSON
------------------------- */
function resetAll(){
  state.features = [];
  state.fileName = null;
  state.lastResults = [];
  $("btnRun").disabled = true;
  $("meta").textContent = "";
  setStatus("<b>Waiting for upload</b>");
  setError(null);
  renderCards([], getThresholds());
}

function getThresholds(){
  return {
    dayStart: +$("dayStart").value,
    dayEnd: +$("dayEnd").value,
    windGo: +$("windGo").value,
    gustGo: +$("gustGo").value,
    rhMin: +$("rhMin").value,
    rhMax: +$("rhMax").value,
    mixGo: +$("mixGo").value,
    qpfMax: +$("qpfMax").value,
    topN: +$("topN").value,
    parallel: +$("par").value,
  };
}

async function handleFile(file){
  setError(null);

  const text = await file.text();
  let obj;
  try { obj = JSON.parse(text); }
  catch(e){ throw new Error("Invalid JSON. Make sure this is a .geojson/.json file."); }

  if(!isFeatureCollection(obj)){
    throw new Error("GeoJSON must be a FeatureCollection with a 'features' array.");
  }

  // filter usable polygon/multipolygon features with tract/name
  const usable = [];
  const skipped = { missingName:0, badGeom:0, badCrs:0 };
  for(const f of obj.features){
    if(!f || f.type!=="Feature") continue;
    const geom = f.geometry;
    if(!geom || !["Polygon","MultiPolygon"].includes(geom.type)){
      skipped.badGeom++; continue;
    }
    const { label } = getBestNameProps(f.properties);
    if(!label){ skipped.missingName++; continue; }

    const c = centroidFromGeometry(geom);
    if(!c){ skipped.badGeom++; continue; }
    if(c.badCRS){ skipped.badCrs++; continue; }

    usable.push({ feature:f, label, lon:c.lon, lat:c.lat });
  }

  if(usable.length===0){
    throw new Error(
      "No usable Polygon/MultiPolygon features found with tract/name.\n" +
      `Skipped: missing name=${skipped.missingName}, bad geometry=${skipped.badGeom}, bad CRS=${skipped.badCrs}\n\n` +
      "Make sure properties include something like Ident/ID and Tract/TractName, and the geometry is WGS84 lon/lat."
    );
  }

  state.features = usable;
  state.fileName = file.name;

  $("btnRun").disabled = false;
  $("meta").textContent = `${file.name} • ${usable.length} units loaded (skipped: name ${skipped.missingName}, geom ${skipped.badGeom}, CRS ${skipped.badCrs})`;
  setStatus(`<b>${usable.length} units loaded</b> — click <b>Fetch weather + rank</b>`);
}

/* -------------------------
   Weather fetch + rank
------------------------- */
async function computeMetricsForUnit(unit, thresholds){
  // 1) points endpoint to get grid + timezone
  const pts = await fetchJson(`https://api.weather.gov/points/${unit.lat.toFixed(5)},${unit.lon.toFixed(5)}`);
  const tz = pts?.properties?.timeZone || "America/New_York";
  const gridUrl = pts?.properties?.forecastGridData;
  if(!gridUrl) throw new Error("No forecastGridData URL from points response.");

  // 2) grid data
  const grid = await fetchJson(gridUrl);
  const p = grid?.properties || {};

  // series
  // RH: relativeHumidity (%)
  const rh = seriesFromGrid(p.relativeHumidity);
  // Wind speed (m/s) + gust (m/s)
  const wind = seriesFromGrid(p.windSpeed);
  const gust = seriesFromGrid(p.windGust);
  // Mixing height (m)
  const mix = seriesFromGrid(p.mixingHeight);
  // QPF (mm)
  const qpf = seriesFromGrid(p.quantitativePrecipitation);

  // next 24
  const rh24 = filterNext24h(rh);
  const wind24 = filterNext24h(wind);
  const gust24 = filterNext24h(gust);
  const mix24 = filterNext24h(mix);
  const qpf24 = filterNext24h(qpf);

  // DAYTIME filters
  const rhDay = filterDaytime(rh24, tz, thresholds.dayStart, thresholds.dayEnd);
  const mixDay = filterDaytime(mix24, tz, thresholds.dayStart, thresholds.dayEnd);

  const rhRange = minMax(rhDay);
  const mixMin = minMax(mixDay);

  // wind/gust max across 24h (daytime wind can be added later if you want)
  const windMax = minMax(wind24);
  const gustMax = minMax(gust24);

  // QPF sum across next 24 (mm → in)
  const qpfSumMm = sum(qpf24);

  // last rain best-effort from past 24h qpf
  const lr = lastRainFromQpfSeries(qpf, tz);

  // Convert units
  // NWS windSpeed/windGust are usually in "unit:m_s-1" (m/s)
  const windMaxMph = windMax ? (windMax.max * 2.23693629) : null;
  const gustMaxMph = gustMax ? (gustMax.max * 2.23693629) : null;

  const mixDayMinFt = mixMin ? metersToFeet(mixMin.min) : null;

  const qpf24In = (qpfSumMm===null) ? null : mmToIn(qpfSumMm);

  let lastRainWhen = null, lastRainAmtIn = null, lastRainReason = null;
  if(lr){
    lastRainWhen = lr.when;
    lastRainAmtIn = mmToIn(lr.amountMm);
  } else {
    lastRainReason = "last rain: no precip found in past 24h (grid QPF)";
  }

  return {
    lat: unit.lat,
    lon: unit.lon,
    timeZone: tz,
    rhDayMin: rhRange ? rhRange.min : null,
    rhDayMax: rhRange ? rhRange.max : null,
    windMaxMph,
    gustMaxMph,
    mixDayMinFt,
    qpf24In: qpf24In ?? 0.00,
    lastRainWhen,
    lastRainAmtIn: lastRainAmtIn ?? 0,
    lastRainReason,
  };
}

// simple concurrency limiter
async function mapLimit(items, limit, fn, onProgress){
  const out = new Array(items.length);
  let i = 0, done = 0;

  async function worker(){
    while(true){
      const idx = i++;
      if(idx >= items.length) return;
      try { out[idx] = await fn(items[idx], idx); }
      catch(e){ out[idx] = { __error: e }; }
      done++;
      if(onProgress) onProgress(done, items.length);
    }
  }

  const workers = [];
  for(let k=0;k<limit;k++) workers.push(worker());
  await Promise.all(workers);
  return out;
}

async function run(){
  const thresholds = getThresholds();
  setError(null);

  if(state.features.length===0){
    setError("No units loaded. Upload a GeoJSON first.");
    return;
  }

  setStatus(`<b>Fetching weather</b> for ${state.features.length} units…`);
  $("btnRun").disabled = true;

  const started = Date.now();
  const resultsRaw = await mapLimit(
    state.features,
    thresholds.parallel,
    async (u)=>{
      const metrics = await computeMetricsForUnit(u, thresholds);
      const dec = scoreUnit(metrics, thresholds);
      return {
        label: u.label,
        metrics,
        score: dec.score,
        decision: dec.label,
        reason: dec.reason
      };
    },
    (done,total)=>{
      setStatus(`<b>Fetching weather</b>… ${done}/${total}`);
    }
  );

  const good = [];
  const errors = [];
  for(let idx=0; idx<resultsRaw.length; idx++){
    const r = resultsRaw[idx];
    if(r && r.__error){
      errors.push(`• ${state.features[idx].label}: ${r.__error.message || r.__error}`);
      continue;
    }
    good.push(r);
  }

  // sort by score desc, then prefer GO
  good.sort((a,b)=>{
    if(b.score !== a.score) return b.score - a.score;
    const rank = (x)=> x==="GO" ? 2 : x==="CAUTION" ? 1 : 0;
    return rank(b.decision) - rank(a.decision);
  });

  // Top N
  const topN = good.slice(0, thresholds.topN);

  const elapsed = Math.round((Date.now()-started)/1000);
  setStatus(`<b>Done.</b> Showing top ${topN.length} of ${good.length} (took ~${elapsed}s).`);

  // Show errors if any (don’t kill the run)
  if(errors.length){
    setError(`Some units failed to fetch/parse:\n${errors.slice(0,20).join("\n")}${errors.length>20?`\n… +${errors.length-20} more`:``}`);
  } else {
    setError(null);
  }

  state.lastResults = topN;
  renderCards(topN, thresholds);
  $("btnRun").disabled = false;
}

/* -------------------------
   Wiring (drop zone)
------------------------- */
const drop = $("drop");
const file = $("file");

drop.addEventListener("click", ()=> file.click());
drop.addEventListener("keydown", (e)=>{ if(e.key==="Enter"||e.key===" "){ e.preventDefault(); file.click(); }});

drop.addEventListener("dragover", (e)=>{ e.preventDefault(); drop.classList.add("drag"); });
drop.addEventListener("dragleave", ()=> drop.classList.remove("drag"));
drop.addEventListener("drop", async (e)=>{
  e.preventDefault();
  drop.classList.remove("drag");
  const f = e.dataTransfer.files?.[0];
  if(!f) return;
  try { await handleFile(f); }
  catch(err){ setError(err.message || String(err)); setStatus("<b>Upload failed</b>"); }
});

file.addEventListener("change", async ()=>{
  const f = file.files?.[0];
  if(!f) return;
  try { await handleFile(f); }
  catch(err){ setError(err.message || String(err)); setStatus("<b>Upload failed</b>"); }
});

$("btnClear").addEventListener("click", resetAll);
$("btnRun").addEventListener("click", run);

resetAll();
</script>
</body>
</html>
